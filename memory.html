<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

<head>
  <link rel="stylesheet" href="main.css"> 
  <title>Recognition Memory Experiment Framework</title>
  <img src="uvicSmall.png" >
  <h1 id="h1">Recognition Memory Experiment Framework</h1>
</head>
<style>
div.backupBoxes{
	opacity:0.64;
}
</style>


<body>

<canvas id="canvasID" width="800" height="800">Error: HTML5 canvas unupported.</canvas>

<script>
</script>

<br>
<div class="backupBoxes">
<textarea rows="7" cols="30" id="backupBox" value = ""></textarea>             
<input type="button" value="backup localStorage" class="backupButton" onclick="backupLocalStorage();"/>
<textarea rows="7" cols="30" id="restoreBox" value = ""></textarea> 
<input type="button" value="restore localStorage" class="restoreButton" onclick="restoreLocalStorage();"/>
</div>

<script>  
var refreshId=false; 
var gridContent;
var puzzlePieceData;

/* this guy gets reset when we clear the persistence structure. */
var progIter=0;
  
function setBackupText(text){
    var textBox = document.getElementById("backupBox");
    textBox.value = text;
}

function backupLocalStorage() {
	var s = "";
  for (var i = 0; i < localStorage.length; i++) {
			var myKey = localStorage.key(i);
			if( i>0){
				s+='þ';
			}
			s+= myKey +'þ'+ localStorage.getItem( myKey);;
  }
  setBackupText(s);//alert(s);
}


function restoreLocalStorage(){
	var textBox = document.getElementById("restoreBox");
	var myData = textBox.value;
	var bigTuple = myData.split('þ');
	if( bigTuple.length %2 ==0){
		localStorage.clear();
		for( var i=0; i< bigTuple.length/2; i++){
			localStorage.setItem( bigTuple[i], bigTuple[i+1]);
		}
	}else{
		textBox.value = "Error: data was not an even number of þ-separated values.";
	}
	//	varInit('progIter');
	varInit('gridContent');
	varInit('puzzlePieceData');
	
}

function setDefaultData(){
	var textBox = document.getElementById("restoreBox");
	if( textBox.value==''){
		textBox.value='0þ1þ1þgridContentþgridContentþ{"0-0":-1,"0-1":-1,"0-2":-1,"0-3":-1,"0-4":-1,"0-5":-1,"0-6":-1,"0-7":-1,"0-8":-1,"1-0":-1,"1-1":-1,"1-2":-1,"1-3":-1,"1-4":-1,"1-5":-1,"1-6":-1,"1-7":18,"1-8":-1,"2-0":-1,"2-1":-1,"2-2":-1,"2-3":-1,"2-4":-1,"2-5":-1,"2-6":25,"2-7":21,"2-8":-1,"3-0":-1,"3-1":-1,"3-2":-1,"3-3":-1,"3-4":-1,"3-5":2,"3-6":15,"3-7":12,"3-8":11,"4-0":-1,"4-1":-1,"4-2":-1,"4-3":6,"4-4":8,"4-5":20,"4-6":7,"4-7":19,"4-8":-1,"5-0":-1,"5-1":0,"5-2":14,"5-3":24,"5-4":1,"5-5":27,"5-6":4,"5-7":10,"5-8":17,"6-0":26,"6-1":5,"6-2":3,"6-3":28,"6-4":13,"6-5":9,"6-6":16,"6-7":22,"6-8":23,"7-0":-1,"7-1":-1,"7-2":-1,"7-3":-1,"7-4":-1,"7-5":-1,"7-6":-1,"7-7":-1,"7-8":-1,"8-0":29,"8-1":30,"8-2":-1,"8-3":31,"8-4":32,"8-5":-1,"8-6":33,"8-7":34,"8-8":-1,"0-9":-1,"1-9":35,"2-9":36,"3-9":-1,"4-9":-1,"5-9":-1,"6-9":-1,"7-9":-1,"8-9":-1}þprogIterþ10þpuzzlePieceDataþ[{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":"[","color":"rgb(0,64,255)","type":"DELAY"},{"text":""},{"text":"","color":"rgb(0,255,255)","type":"RESPONSE"},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":""},{"text":"","color":"rgb(255,0,191)","type":"TEST-PHASE"},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":"","color":"rgb(0,255,64)","type":"INSTRUCTIONS"},{"text":""},{"text":"","color":"rgb(128,0,255)","type":"STUDY-PHASE"},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""}]';
		//textBox.value= '0þ1þ1þgridContentþgridContentþ{"0-0":-1,"0-1":-1,"0-2":-1,"0-3":-1,"0-4":-1,"0-5":-1,"0-6":-1,"0-7":-1,"0-8":-1,"1-0":-1,"1-1":-1,"1-2":-1,"1-3":-1,"1-4":-1,"1-5":-1,"1-6":-1,"1-7":18,"1-8":-1,"2-0":-1,"2-1":-1,"2-2":-1,"2-3":-1,"2-4":-1,"2-5":-1,"2-6":25,"2-7":21,"2-8":-1,"3-0":-1,"3-1":-1,"3-2":-1,"3-3":-1,"3-4":-1,"3-5":2,"3-6":15,"3-7":12,"3-8":11,"4-0":-1,"4-1":-1,"4-2":-1,"4-3":-1,"4-4":-1,"4-5":20,"4-6":7,"4-7":19,"4-8":-1,"5-0":-1,"5-1":-1,"5-2":-1,"5-3":-1,"5-4":1,"5-5":27,"5-6":4,"5-7":10,"5-8":17,"6-0":-1,"6-1":-1,"6-2":-1,"6-3":14,"6-4":24,"6-5":9,"6-6":16,"6-7":22,"6-8":23,"7-0":26,"7-1":5,"7-2":3,"7-3":28,"7-4":13,"7-5":8,"7-6":0,"7-7":6,"7-8":-1,"8-0":29,"8-1":30,"8-2":-1,"8-3":31,"8-4":32,"8-5":-1,"8-6":33,"8-7":34,"8-8":-1,"0-9":-1,"1-9":35,"2-9":36,"3-9":-1,"4-9":-1,"5-9":-1,"6-9":-1,"7-9":-1,"8-9":-1}þprogIterþ1þpuzzlePieceDataþ[{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":"[","color":"#0040ff","type":"DELAY"},{"text":""},{"text":"","color":"#00ffff","type":"RESPONSE"},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":""},{"text":"","color":"#ff00bf","type":"TEST-PHASE"},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":""},{"text":""},{"text":"","color":"rgb(230,226,224)","type":null},{"text":""},{"text":"","color":"#00ff40","type":"INSTRUCTIONS"},{"text":""},{"text":"","color":"#8000ff","type":"STUDY-PHASE"},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""},{"text":""}]';
	}
}




/*
<input type = "text" id="backupBox" value = "" style="width: 300px; height: 400px;"  /> 

<select name="element">
  <option value="button">Button</option>
  <option value="text">Textbox</option>
  <option value="radio">Radio</option>
</select>

<input type="button" value="Add" onclick="alert('hi');"/>




standard hsv to rgb conversion... 

h is in range [0--> 60]..... 
s, v are in range [0,1]...

*/
var hsv2rgb = function(h,s,v) { /*   var h = hsv.hue, s = hsv.sat, v = hsv.val; */
  var rgb, i, data = [];
  if (s === 0) {
    rgb = [v,v,v];
  }
  else{
    h = h / 60;
    i = Math.floor(h);
    data = [v*(1-s), v*(1-s*(h-i)), v*(1-s*(1-(h-i)))];
    switch(i) {
      case 0:	 rgb= [v, data[2], data[0]]; break;
      case 1:  rgb= [data[1], v, data[0]]; break;
      case 2:  rgb= [data[0], v, data[2]]; break;
      case 3:  rgb= [data[0], data[1], v]; break;
      case 4:  rgb= [data[2], data[0], v]; break;
      default: rgb= [v, data[0], data[1]]; break;
    }
  }
  return '#' + rgb.map(function(x){ 
    return ("0" + Math.round(x*255).toString(16)).slice(-2);
  }).join('');
};

/*  Color conversion.....from 
	http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb

The following will do to the RGB to hex conversion and add any required zero padding: 
*/
function componentToHex(c) {
    var hex = c.toString(16);
    return hex.length == 1 ? "0" + hex : hex;
}  
function _rgbToHex(r, g, b) {
    return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
}

function rgbToHex( rgb){
	var mySlice= rgb.slice(4,rgb.length-1);
	var myFrags =mySlice.split(',');
	return( _rgbToHex( parseInt(myFrags[0]), parseInt(myFrags[1]), parseInt(myFrags[2])));
}

/* converting in the other direction.... also from:
	http://stackoverflow.com/questions/5623838/rgb-to-hex-and-hex-to-rgb

*/
function hexToRgb(hex) {
    var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return 'rgb('+parseInt(result[1], 16).toString()+','+ parseInt(result[2], 16).toString()+','+ parseInt(result[3], 16)+ ')';
    /*return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;*/
}  /* alert( hexToRgb("#0033ff").g );   */


	var canvasHeight = 801;
  var plopSound = new Audio('plop.mp3'); 
  
  /* check if localStorage is supported.. should be, for most relatively current browsers. 

  */
  function hasLocalStorage(){ 
    var test = 'test';
    try{
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    }catch(e){
      return(false);
    }
  }
 
  /* keep hooks to our html5 canvas, and canvas.context.. */
  var canvas, ctx; 

  /* check if html5-canvas is supported.. */
  function canvasSupported(){
    canvas = document.getElementsByTagName("canvas")[0];
    ctx = canvas.getContext('2d');
    return( !!(ctx));
  }
   
  /* check that the prerequisites are satisfied, and set up the canvas.. */ 
  function init(){
    setDefaultData();
      
    console.log('checking prerequisites..');
    if(!hasLocalStorage()){
      alert('Error:\nHTML5:localStorage unavailable.\n\nUpdate your browser.');
      return;
    }
    if(!canvasSupported()){
      alert('Error: HTML5 canvas not supported. Please update your browser.');
      return;
    }else{
      ctx.width = 800; 
			ctx.height= canvasHeight; 
    }

    console.log('prerequisites seem to be ok..');
  };

  /* don't pass go without the canvas and localStorage.. */
  init();
  
  
 /* State variables */  //  
  gridContent = {}; 
  
 if(false){
		/* sometimes for debugging, need to clear saved state.. */
		localStorage.removeItem('gridContent');
		localStorage.removeItem('puzzlePieceData');
 } 
  /* 
  
			gridContent	<--- this variable indicates if the grid square:  
			at location:  
					'(' + i.toString() +',' + j.toString() + ')'   (***) 
      is occupied. 
      
      The variable holds a name (a number >=0) of the occupying 
      puzzle piece. If the grid location is empty, the value is 
      set to -1;
      
      gridContent maps from (***) to the index in puzzlePieceData 
			(or -1 if the square (***) is empty..)
  */
   
  puzzlePieceData = new Array( 5 * Math.ceil( ctx.width / 100) * Math.ceil( ctx.height/100));
  /* There's an arbitrary constant in the above array, 
			because when we support deleting/creating, we need to add space 
			(don't have time to implement the appropriate garbage collection 
			on this iteration... 
			
			Ideally re-use tiles without overly creating/deleting... 
  
  */
  
  for( var i=0; i<puzzlePieceData.length; i++){
    puzzlePieceData[i] = { 'text':'' } ; //let's add a 'text' property later.. and other properties. 
  }
  var nextPuzzlePieceName = 0;

  var pickThis = ''; //this gets set to a certain 'cI' if a certain grid element gets picked. 
  var selectedItem = ''; /* Something that gets picked will get selected. You can unselect it by rePicking. */
  var selectedX  = '';
  /* set up keyboard handlers, and keyboard state variables.. */
  var lastKeyPressed = ''; //track the last key pressed (onkeydown).. 

 
	function getKeys(obj) {
		var r = []
		for (var k in obj) {
			if (!obj.hasOwnProperty(k)) 
				continue
			r.push(k)
		}
		return r
	}
		
 
   /* transfer inMemory variable to localStorage.. 
   
   NB variables need to be defined at the top, for this to work..
   
   */
	function varSave(variableName){
		var myValue = eval('JSON.stringify('+variableName+');');
		localStorage.setItem(variableName, myValue);
		//eval('localStorage.setItem('+variableName+',JSON.stringify('+variableName+'));');
		//localStorage.setItem(variableName, eval('JSON.stringify('+variableName+');'));
	}
	
	/* 
			transfer localStorage version to inMemory variable (if available)..
			otherwise, initialize a new localStorage version.. 
			N.B., not really a version: more like a copy!
	
	*/
  function varInit(variableName){  /* init variable, but restore if not already defined... */
		var item = localStorage.getItem(variableName);
		if(item==null){
			/* no localStorage copy to restore-- so, write one:  */
			varSave(variableName);
			eval('console.log('+variableName+');');
			return(eval(variableName));
		}else{
		 /* restore localStorage copy. */
		  eval(variableName+' = JSON.parse(item);');
		  eval('console.log('+variableName+');');
		  return(JSON.parse(item));
		}
	}

	if(true){
		progIter = varInit('progIter');
		if(false)document.getElementById("h1").innerHTML = "Recognition Memory Experiment Framework (iter="+progIter.toString()+")";
		progIter++;
		varSave('progIter');
	}	
  
  var invColor;
  var img = new Image(); 
  img.src = 'uvicAerial.jpg';  
  var avgColor = [0.,0.,0.];
  
  
  function resolveColor(color){
    // return an array containing R, G and B values
    if(color === 'transparent')// IE (6 and ?)
        color = '#FFF';
    var r,g,b;
    var hex_color_pcre = new RegExp("^#[0-9a-f]{3}([0-9a-f]{3})?$",'gi');
    var rgb_color_pcre = new RegExp("rgb\\(\\s*((?:[0-2]?[0-9])?[0-9])\\s*,\\s*((?:[0-2]?[0-9])?[0-9])\\s*,\\s*((?:[0-2]?[0-9])?[0-9])\\s*\\)$",'gi');
    var rgb_percent_color_pcre = new RegExp("rgb\\(\\s*((?:[0-1]?[0-9])?[0-9])%\\s*,\\s*((?:[0-1]?[0-9])?[0-9])%\\s*,\\s*((?:[0-1]?[0-9])?[0-9])%\\s*\\)$",'gi');
    if(color.match(hex_color_pcre)){
        if(color.length == 4){
            r  = color.charAt(1)+""+color.charAt(1);
            g  = color.charAt(2)+""+color.charAt(2);
            b  = color.charAt(3)+""+color.charAt(3);
        }
        else{
            r  = color.charAt(1)+""+color.charAt(2);
            g  = color.charAt(3)+""+color.charAt(4);
            b  = color.charAt(5)+""+color.charAt(6);
        }
        r = h2d(r);
        g = h2d(g);
        b = h2d(b);
    }
    else if(color.match(rgb_color_pcre)){
        r = RegExp.$1;
        g = RegExp.$2;
        b = RegExp.$3;
    }
    else if(color.match(rgb_percent_color_pcre)){
        r = parseInt((RegExp.$1)*2.55);
        g = parseInt((RegExp.$2)*2.55);
        b = parseInt((RegExp.$3)*2.55);
    }
    else
        return false;

    /*var returned =[];
    returned['red'] = r;
    returned['green'] = g;
    returned['blue'] = b;*/
    return( 'rgb('+r.toString()+','+g.toString()+','+b.toString()+')');
//    return returned;
}


    
  function inverseColor( _rgbColor){
 
		var rgbColor = resolveColor(_rgbColor);
    /*Return the string for the complementary inverse color, 
    for a color string of the format:
      rgb(230,226,224) 
    */
    var values = (rgbColor.slice(4, rgbColor.length-1)).split(',');
    /* should now have a string array like this:
	  230,226,224  */
    var s = 'rgb(';
    for( var i=0; i<3; i++){
      s+= (255-parseInt(values[i])).toString();
      if( i<2){
				s+=',';
      }
    }
    return(s+')'); 
  }
  
  img.onload = function() {
    /* 
      When the background image loads, calculate an approximation 
	to the average colour of the image. Ideally we would use 
	an offscreen canvas or other method to do this, if we had more time.
	
	First: set the canvas size to the background image:
    */
    ctx.width = img.width; 
    ctx.height = img.height;
    
    /* 
      Draw the background image (temporarily) on the canvas. Read the data
	values back in, and sample them to get an approximate average 
	value of the colour of the background image. 
    */
    ctx.drawImage(img, 0, 0); //write bg image to the canvas. 
    var imageData = ctx.getImageData(0, 0, img.width, img.height);
    var pix = imageData.data; //read back the pixel data. 
    var nn = 0;	//count the number of points used in the sample. 
    var nSkip = 7777; 
    /* use a sample/fraction of the image data, to save time.. */
    for (var i = 0; i < pix.length; i+=4) {
      /* Use (1/nSkip) of the image pixels. */
      if( i%nSkip==0){
				var r = 1.*pix[i  ];//red
				var g = 1.*pix[i+1];//green
				var b = 1.*pix[i+2];//blue
				avgColor[0]+=r; avgColor[1]+=g; avgColor[2]+=b; 
				nn+=1.; /* keep track of the number of elements in the sample. */
			}/* Note: pix[i+3] is 'alpha' (the fourth element) */
		}
    /* divide by sample mean to get an approximation of the average: */
    avgColor[0]/=nn;avgColor[1]/=nn; avgColor[2]/=nn;
    /* calculate the inverted colour. */
    invColor = 'rgb(' 
			+(255-Math.floor(avgColor[0])).toString() +','
			+(255-Math.floor(avgColor[1])).toString() +','
			+(255-Math.floor(avgColor[2])).toString() 
			+')'; 
    avgColor = inverseColor( invColor);//represent the original in the same format. 
  } //img.onload = function() 

  ctx.width = 800; 
  ctx.height= canvasHeight;//  800; 


  
  /* convert a string of form:
	'1,2'
	
     to a pair of integers of form:
	[1,2]
  */
  function toPair( ci){
    var parts = ci.split('-');  //use - as separator for our "pair" construction. 
    for(var i=0; i<2; i++){
      parts[i]=parseInt(parts[i]);
    }
    return( parts);
  }
  
  /* 
    Disable scroll down when spacebar is pressed
  */
  window.onkeydown = function(e) { 
    return !(e.keyCode == 32);
  };

  /* Check if a string (or character) is all upper case. */
  function allUpperCase(s){
    var ss = s.toString();
    return( ss == ss.toUpperCase());
  }

  
  var shiftKey = false; 
  /*
    
  */


  
  function keyboard_module(onUpdate) {
    var kb = {};
    var unicode_mapping = {};
    /* handler for key down event.. override automatic key repeats!
    
	With the exception of BACKSPACE.. !!!
    */
    document.onkeydown = function(e) {
      //console.log( 'key code: '+ (e.keyCode).toString()+ ' charCode: '+(e.charCode).toString()); 
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      if(lastKeyPressed!='' && (lastKeyPressed==key) && ( unicode!=8)){
        return;
      }
      console.log('unicode: ',unicode)
      lastKeyPressed =key;
      kb[key] = true;
      if (onUpdate) {
        onUpdate(kb);//alert(key);
      }
      if( unicode ==16){
				shiftKey =true; 
      }
      if( selectedItem!=''){
				//console.log('Selected item!!!!');
				var myName = gridContent[ selectedItem];
				var curText = (puzzlePieceData[myName])['text'];
				if( !curText){ curText = '';}
				var newValue = String.fromCharCode(unicode);
				if( unicode==8){
					/* backSpace (need to add other 'control' characters..) */
					if( curText.length >1){
						curText = curText.slice(0, curText.length-1);
					}
				}else{
					//var gridCoords = toPair( selectedItem);

					if( unicode ==13){
						newValue = '\n';
						/* right now enter doesn't effectively do anything. 
					(would have to modify the wrapText method). 
						*/
					}
					function reMap(u,newVal, shiftVal){
						var ret = newValue; 
						if(unicode==u){
							ret = newVal; 
							if(shiftKey){
								ret = shiftVal; 
							}
						}
						return(ret);
					}
					newValue= reMap(190,  '.',  '>');
					newValue= reMap(188,  ',',  '<'); //might need to  
					newValue= reMap(186,  ';',  ':');
					newValue= reMap(222,  "'",  '"');
					newValue= reMap(191,  '/',  '?');
					newValue= reMap(219,  '[',  '{');
					newValue= reMap(221,  ']',  '}');
					newValue= reMap(220,  "\\", '|'); //might need to disable backslash later. 
					newValue= reMap(221,  ']',  '}');
					newValue= reMap(192,  '`',  '~');
					newValue= reMap( 49,  '1',  '!');
					newValue= reMap( 50,  '2',  '@');    
					newValue= reMap( 51,  '3',  '#');
					newValue= reMap( 52,  '4',  '$');
					newValue= reMap( 53,  '5',  '%');
					newValue= reMap( 54,  '6',  '^');
					newValue= reMap( 55,  '7',  '&');
					newValue= reMap( 56,  '8',  '*');
					newValue= reMap( 57,  '9',  '(');
					newValue= reMap( 48,  '0',  ')');
					newValue= reMap(189,  '-',  '_');
					newValue= reMap(187,  '=',  '+');
					if( shiftKey ){
						newValue = (newValue.toString()).toUpperCase();
					}else{
						newValue = (newValue.toString()).toLowerCase();
					}
					curText+= newValue.toString(); //unicode.toString();
				}
				(puzzlePieceData[myName])['text']=curText;
			}
		}
    /* handler for key up event.. */
    document.onkeyup = function(e) {
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      lastKeyPressed = '';
      delete kb[key];
      if (onUpdate) {
        onUpdate(kb);
      }

			if( unicode ==16){
				shiftKey =false; 
			}
    }
    /* function to check the keyboard state.. */
    function getKey(unicode) {
      if (unicode_mapping[unicode]) {
        var key = unicode_mapping[unicode];
      } else {
        var key = unicode_mapping[unicode] = String.fromCharCode(unicode);
      }
      return key;
    }
    return kb;
  }/* function keyboard_module(onUpdate).. keyboard handler..  */

  /* by default, log which keys are currently down.. */
  function testing(kb) {
    console.log('These keys are down: ', kb); //These keys are down:  Object {S: true} //e.g., for S pressed... 
  }

  /* set up the keyboard event handling scheme above.. */
  var keyboard = keyboard_module(testing);
  


  /* function to convert window mouse coordinates to canvas mouse coordinates. */
  function windowToCanvas(canvas, x,y){
    var bbox = canvas.getBoundingClientRect();
    return { x:(x-bbox.left)*(canvas.width/bbox.width),
       y:(y-bbox.top) *(canvas.height/bbox.height)};
    /*  
      //Example use of windowToCanvas:  
        canvas.onmousemove=function(e){
          var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        };
      //End example..
    */
  }
  
  //----------------------------------------------------------------------------
var cw=canvas.width;
var ch=canvas.height;
function reOffset(){
  var BB=canvas.getBoundingClientRect();
  offsetX=BB.left;
  offsetY=BB.top;        
}
var offsetX,offsetY;
reOffset();


function makeBeziers(s){
  var ret = ([
    {cx1:0,  cy1:15,  cx2:35,cy2:15, ex:37, ey:5},   // left shoulder
    {cx1:37, cy1:5,  cx2:40,cy2:0,  ex:38, ey:-5},  // left neck
    {cx1:38, cy1:-5, cx2:20,cy2:-20,ex:50, ey:-20}, // left head
    {cx1:50, cy1:-20,cx2:80,cy2:-20,ex:62, ey:-5},  // right head
    {cx1:62, cy1:-5, cx2:60,cy2:0,  ex:63, ey:5},   // right neck
    {cx1:63, cy1:5,  cx2:65,cy2:15, ex:100,ey:15},   // right shoulder
  ]);
  for( var i = 0; i<ret.length; i++){
     ret[i].cx1*=s;
     ret[i].cx2*=s;
     ret[i].cy1*=s;
     ret[i].cy2*=s;
     ret[i].ex*=s;
     ret[i].ey*=s;
  }
  return ret;
}


function drawUp(transX,transY, reverseDirection, pw){
  //ctx.translate(transX,transY);
  var bSet = makeBeziers(1.*(pw/100.));
  var tx  = transX; 
  var ty  = transY;
  if( reverseDirection==true){
    for(var i=bSet.length-1; i>=0; i--){
      var b=bSet[i];
      ctx.bezierCurveTo(b.ex+tx,b.ey+ty,b.cx2+tx,b.cy2+ty,b.cx1+tx,b.cy1+ty);
    }
  }else{
    for(var i=0;i<bSet.length;i++){
      var b=bSet[i];
      ctx.bezierCurveTo(b.cx1+tx,b.cy1+ty,b.cx2+tx,b.cy2+ty,b.ex+tx,b.ey+ty);
    }
  }
}
function drawLine(x,y,u,v){ //ctx.beginPath(); 
  ctx.moveTo(x,y);  
  ctx.lineTo(u,v); //ctx.closePath(); //ctx.stroke();
}

/* Draw a puzzle piece that only can have vertical connections. */
function drawPiece(aTransX,aTransY, /* <-translation offset.. */ pw,ph /* <-puzzle piece dims..*/ , isSelected, cI){ 
  
  var puzCoords = toPair( cI);
  var transX = aTransX; 
  var transY = aTransY;
   
  ctx.lineWidth=0.5;
  ctx.strokeStyle='blue';
  var sizeP = ph;//100; 
  var pp = 15 * (100./pw);
  //sizeP = 100-pp;
  /* Draw the shape (without edges). */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,transX, transY+pp);
  drawUp(transX, transY, false, pw);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawUp(transX, transY+sizeP, true, pw);//false);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.closePath();
  var myFillColor=''; 
  if( puzCoords[0]==7){
		
		myFillColor=/*ctx.fillStyle=*/ hsv2rgb((360/8.)*((puzCoords[1]+3)),1,1);
		(puzzlePieceData[gridContent[cI]])['color']=myFillColor;
		
		function assignTypeString(val) {
			var answer = "";
			switch( val ) {
			case 0: 
				return("INSTRUCTIONS");
				break;
			case 1: 
				return("RESPONSE");
				break;
			case 2: 
				return("DELAY");
				break;
			case 3: 
				return("STUDY-PHASE");
				break;
			case 4: 
				return("TEST-PHASE");
				break;
			Default:
				return(null);//answer = "Massive or Tiny?";
			} 
			return answer;  
		}
		if( puzCoords[1] <=4 ){
			(puzzlePieceData[gridContent[cI]])['type']=assignTypeString(puzCoords[1]);
		}
		else{
			(puzzlePieceData[gridContent[cI]])['type']=null;//assignTypeString(puzCoords[1]);
			myFillColor=/*ctx.fillStyle=*/ (isSelected==true)?avgColor:invColor;//inverseColor(invColor);
			(puzzlePieceData[gridContent[cI]])['color']=invColor;
			
		}
		
  }else{
		myFillColor=/*ctx.fillStyle=*/ (isSelected==true)?avgColor:invColor;//inverseColor(invColor);
		var savedColor =(puzzlePieceData[gridContent[cI]])['color'];
		if( savedColor){
		
			if(  ((savedColor.toString())[0])=='#'){
				savedColor = hexToRgb( savedColor);
				(puzzlePieceData[gridContent[cI]])['color'] = savedColor;
			}
		}
		//console.log('savedColor', savedColor);
		if(savedColor ){

			myFillColor=(isSelected==true)?inverseColor(savedColor):savedColor;
		}
	} 
	ctx.fillStyle=myFillColor;

  ctx.fill();
  
  /* draw the picking area.. MAYBE only draw this when the piece is highlighted!!! */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,   transX, transY+pp);
  drawLine(     transX, transY+pp,transX+pw, transY+pp);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawLine(  transX+pw, transY+sizeP+pp,transX, transY+sizeP+pp);
  ctx.closePath();
  ctx.strokeStyle='green';
  ctx.stroke();
  
  var fontSize = 11;
  /* Now, draw the text content..  */
  function wrapText(str, startY, isSelected, isBold){  //with some help from ashblue
    var words = str.split(" ");
    var myX = 10;
    var myY = 50;
    var line = '';
    var lines = [ ] ;
    var lineTest = '';
    
    ctx.font = fontSize +"px Arial";
    if(isBold){
			ctx.font = "Bold Italic "+ctx.font;
    }
    ctx.fillStyle = (isSelected)?invColor:avgColor;
    try{
			//ctx.fillStyle = (isSelected)?inverseColor(myFillColor):myFillColor;//invColor:avgColor;//'blue';
    }catch(e){
			ctx.fillStyle = (isSelected)?invColor:avgColor;
    }
    for(var j=0; j<words.length; j++){
      lineTest = line + words[j] + ' ';
      if( ctx.measureText(lineTest).width > 100){
				myY = lines.length * fontSize + fontSize;
				lines.push( {text: line, height: myY});
				line = words[j] + ' ';
      }else{
				line = lineTest; 
      }        
    } 
    // Catch last line in-case something is left over
    if (line.length > 0) {
      currentY = lines.length * fontSize + fontSize;
      lines.push({ text: line.trim(), height: currentY });
    }   
    // Visually output text
    //ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var j = 0, len = lines.length; j < len; j++) {
      ctx.fillText(lines[j].text, transX, lines[j].height+ startY);
    }
  }
  var myString = (puzzlePieceData[gridContent[cI]])['text'];
  var myType = (puzzlePieceData[gridContent[cI]])['type'];
  if( myType ){
		wrapText( myType.toString()+":", transY+15, isSelected, true);
		wrapText( myString, fontSize+transY+15, isSelected,false); 
  }else{
		wrapText( myString, +transY+15, isSelected,false); 
  }
  
  
  
}



/*
  Draw the grid. 
  
  Also, (for now), randomly initialize (empty) puzzle piece
    elements on the grid. 
*/
function drawGrid(cw, ch){
  /*
     Draw the grid. 
  */
  var v = 36;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth=1;
  ctx.strokeStyle='blue';
  ctx.setLineDash([5, 15]);
  for( var i=0; i<cw/100; i++){
    drawLine( i * 100, 0+v, i*100, ch+v);    ctx.stroke();
  }
  for(var j=0; j<ch/100; j++){
    drawLine(0, j*100+v, cw, j*100+v);     ctx.stroke();
  }
  
  /* Randomly initialize puzzle piece elements on the grid (for now).. 
	Change this later.. 
  */
  if( progIter<1){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
				//pass
      }else{
				if( Math.random()<.4){////if( i%3==0 || j%==0){
					gridContent[cI]=(nextPuzzlePieceName++);
				}else{
					gridContent[cI]=-1;
				}
      }
    }
  }
 }
 ctx.globalAlpha = 1.;
}

/*
  Draw the puzzle pieces on the grid. 
*/
function drawGridContent(){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
	if(gridContent[cI]>=0){
	  if( pickThis == cI){
	    /* Mouse motion: puzzle piece follows mouse coordiantes: */
	    drawPiece(mx, my, 100,100, cI==selectedItem, cI);
				//0 + 100*i,21 + 100*j, 100,100);
	  }else{
	     //Puzzle piece is static: 
	    drawPiece(0 + 100*i,21 + 100*j, 100,100, cI==selectedItem, cI);
	  }
	      //draw(mx, my, 100, 100);
	}
      }
    }
  }
}


var w = 800;//window.innerWidth-20;
var h = canvasHeight;//800;//window.innerHeight-20; 
drawGrid(w,h);
drawGridContent();

/*
	This comment used to read
	"Before drawing or initializing the grid, try to restore it:"
	
	.. but now, we need to adjust that statement, because we would like to 
		initialize the variables schema, in order to dump data into them.. 
*/
if(progIter>0){
	varInit('gridContent');
	varInit('puzzlePieceData');   //next, use JSON.stringify() and JSON.parse()
	/*
		progIter = varInit('progIter');
		document.getElementById("h1").innerHTML = "Recognition Memory Experiment Framework (iter="+progIter.toString()+")";
		progIter++;
		varSave('progIter');
	*/	
}
//----------------------------------------------

 /* Global variables to track animation loop.. */
  var i=0; //loop iteration counter. 
  var movingAverage = 0.; //moving average for fps calc... 
  var t0 = window.performance.now(); //start time..
  var t2 = 0; var t1=t0; //times used in loop..
  
  
  var mx, my; mx=my=0;

  /* function to execute, animation loop.. */
  function frame(){
    //document.bgColor = "#FFFFFF"; //"#000000"

    var w = 800;//window.innerWidth-20;
    var h = canvasHeight;//800;//window.innerHeight-20; 
    /* set the canvas size dynamically so that the software is device independent and so on... */    
    canvas.width  = w;
    canvas.height = h;


    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    
    /* Image scaling approach for logo (right corner) */
    /*
    ctx.save();
      ctx.globalAlpha = 1.0;
      var lW = logoImg.width; var lH = logoImg.height;
      var wf = (w-20)/(5. * lW);
      ctx.drawImage( logoImg, w-(lW*wf),h-(lH*wf),lW*wf, lH*wf);
    ctx.restore();
    */
    
    drawGrid(w,h);
    drawGridContent();
  
    /*loop profiling section */
    var t2 = window.performance.now()
    if( i==1){
      movingAverage = t1 - t0;
    }else{
      movingAverage = (movingAverage +(t2-t1))/2.;
    }
    t1 = t2; 
    if (i % 1000 == 0) {
      console.log(movingAverage.toString()+(' mS = ')+((1./(movingAverage/1000.)))+(' fpS'));
    }
    /* Total time elapsed since start.. */
    var timeElapsed = Math.ceil(( t1-t0)/1000.);  i += 1;
    if(false){
      /* print out DOM element names... 
      
	 Was looking to see if generally there was a pattern, 
	  the two methods for exploring the DOM don't seem 
	  to give the same results. 
      */
      var all = document.getElementsByTagName("*");
      for (var i=0, max=all.length; i < max; i++) {
	// Do something with the element here	
	console.log( all[i].toString() + ' i='+ i.toString());
      }

      var currentNode,
      ni = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_ELEMENT);

      while(currentNode = ni.nextNode()) {
				console.log(currentNode.nodeName);
      }
    }
    
			if( localStorage.getItem( 'gridContent')==null ){
				/* break out of the loop if we have cleared localStorage..*/
				//alert('localStorage not available.');
				//throw '';
				console.log('clearInterval.');
				
				clearInterval(refreshId);
				
			}else{
				varSave('gridContent');
				varSave('puzzlePieceData');
			}
  };
  
  /* Mouse button down event */
  canvas.addEventListener("mousedown", function(e){  /* e.clientX, e.clientY */
    /* mouse down event listener code... */ 
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    var cw = canvas.width;
    var ch = canvas.height;
    var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
    /* Did we click on a 'valid' grid square? */
    if( cI in gridContent){
      pickThis = cI; 
      /* was this item already selected? */
      if( selectedItem ==cI){
				/* If the picked item was already selected, unselect it. */
				selectedItem = '';
			}else{
				/* If the picked item was not already selected, select it! */
				selectedItem = cI;
				var selectedItemColor = (puzzlePieceData[gridContent[cI]])['color'];\
				if(selectedItemColor!=null){
					console.log('selectedItem.color:',selectedItemColor);
				}
				/* Track the starting mouse position for the selection 
					.. the idea was to use this as an "offset", later. 
				*/
				selectedX = [mx, my]; 
      }
    }
    
  });

  /* Mouse up event.. */
  canvas.addEventListener("mouseup", function(e){  /* e.clientX, e.clientY */
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    if( pickThis!=''){
      var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
      if( cI in gridContent){
	if( gridContent[cI]<0 /*==''*/ /* only move to empty space*/ 
	    && (cI!=pickThis)  /* if dest=src then don't move!!!!..  */ ){
	  plopSound.play();
	  console.log('Overwriting '+cI+' with '+pickThis+ ' puzzlePieceName=' 
	    +(gridContent[pickThis]).toString());
	  gridContent[cI]=gridContent[pickThis];
	  gridContent[pickThis]=-1;//'';
	}
      }
    }
    /* keep the status quo. */
    pickThis ='';
  });
  
  canvas.onmousemove=function(e){
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    return;
    console.log(
	'x '+(e.clientX).toString()+' y '+(e.clientY).toString()
      + ' cx '+(loc.x).toString()
      + ' cy '+(loc.y).toString()
      + ' i  '+Math.floor(loc.x / 100).toString()
      + ' j  '+Math.floor(loc.y / 100).toString()
      );
  };

  /* this command actually starts the animation-loop:.. */
  refreshId = setInterval(frame, 88);  //Can reduce this number to decrease latency..  
  
</script>
</body>
</html>
