<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>
  <link rel="stylesheet" href="memory.css"> 
  <title>Recognition Memory Experiment Framework</title>
  <img src="site/uvicSmall.png" >
  <h1 id="h1">Recognition Memory Experiment Framework</h1>
</head>
<style>
div.backupBoxes{ opacity:0.64; }
div.stimulusPools{ opacity:0.97; }
div.radioButtons{ background-color: lightgray; opacity:0.89;}
</style>
<body>
<canvas id="canvasID" width="800" height="800">Error: HTML5 canvas unupported.</canvas><br>
<div class="stimulusPools"><br>

<div class="radioButtons" style="width: 800px; "> 
Time limit    (mS)   <input type="number" name="isi" min="0" max="10000" step="1000" value="0">
Time interval (mS) <input type="number" name="set" min="0" max="10000" step="1000" value="0">
<br>
N: <input type="number" name="p1n" id="p1n" min="0" max="100" step="1" value="30">
M: <input type="number" name="p1m" id="p1m" min="0" max="100" step="1" value="30">

<input type="radio" id = "p1on" name = "p1" onchange="p1on();"  checked=false><label for="p1on">pool1 on</label>   
<input type="radio" id = "p1of" name = "p1" onchange="p1on();"  checked=true><label for="p1of"> off</label>   
<script type="text/javascript">
/* 
http://viralpatel.net/blogs/dynamic-add-textbox-input-button-radio-element-html-javascript/   
*/
  function p1on() {	var e = document.getElementById('p1on');	console.log( e.checked); }
</script>


N: <input type="number" name="p2n" min="0" max="100" step="1" value="30">
M: <input type="number" name="p2m" min="0" max="100" step="1" value="30">

<input type="radio" id = "p2on" name = "p2" onchange="p2on();"  checked=false><label for="p2on">pool2 on</label>
<input type="radio" id = "p2of" name = "p2" onchange="p2on();"  checked=true><label for="p2of"> off</label>
<script type="text/javascript">
  function p2on() {
			var e = document.getElementById('p2on');
			console.log( e.checked);		
		}
</script>

N: <input type="number" name="p3n" min="0" max="100" step="1" value="30">
M: <input type="number" name="p3m" min="0" max="100" step="1" value="30">

<input type="radio" id = "p3on" name = "p3" onchange="p3on();"  checked=false><label for="p3on">pool3 on</label>
<input type="radio" id = "p3of" name = "p3" onchange="p3on();"  checked=true><label for="p3of"> off</label>
<script type="text/javascript">
  function p3on() {
			var e = document.getElementById('p3on');
			console.log( e.checked);		
		}
</script>

<script src="js/defaultData.js"></script>
<script src="js/keyboardModule.js"></script>

</div>

<textarea rows="7" cols="30" id="stimulusBox1" value = ""></textarea> 
<input type="button" value="default" class="stimPooldefault1" onclick=""/>

<textarea rows="7" cols="30" id="stimulusBox2" value = ""></textarea> 
<input type="button" value="default" class="stimPooldefault2" onclick=""/>

<textarea rows="7" cols="30" id="stimulusBox3" value = ""></textarea> 
<input type="button" value="default" class="stimPooldefault3" onclick=""/>

<br>

<div class="radioButtons" style="width: 800px; "> 
<input type="radio" id = "q1on" name = "q1" onchange="q1on();"  checked=false><label for="q1on">Question on</label>   
<input type="radio" id = "q1of" name = "q1" onchange="q1on();"  checked=true><label for="q1of"> off</label>  
<script type="text/javascript">
  function q1on() { var e = document.getElementById('q1on'); console.log( e.checked);		}
</script>
</div>
<textarea rows="7" cols="30" id="questionBox" value = ""></textarea> 
<input type="button" value="default question" class="questionBox" onclick=""/>

<textarea rows="7" cols="30" id="answerBox" value = ""></textarea> 
<input type="button" value="default response" class="questionBox" onclick=""/>
<br>
</div>


<br>
<div class="backupBoxes">
<textarea rows="7" cols="30" id="backupBox" value = ""></textarea>             
<input type="button" value="backup localStorage" class="backupButton" onclick="backupLocalStorage();"/>
<textarea rows="7" cols="30" id="restoreBox" value = ""></textarea> 
<input type="button" value="restore localStorage" class="restoreButton" onclick="restoreLocalStorage();"/>
</div>
<script src="js/displayKeyCode.js"></script>

<INPUT ONKEYPRESS="javascript:return false;" ID="txtChar" ONKEYDOWN="javascript:return displayKeyCode(event);" TYPE="text" NAME="txtChar">
<script src="js/localStorage.js"></script>
<script src="js/formEventHandlers.js"></script>


<script src="js/colourTransform.js"></script>
<script src="js/util.js"></script>

<script>  
	var canvasHeight = 801;
  var plopSound = new Audio('site/plop.mp3'); 
  
  /* check if localStorage is supported.. should be, for most relatively current browsers. */
  function hasLocalStorage(){ 
    var test = 'test';
    try{
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    }catch(e){
      return(false);
    }
  }
 
  /* keep hooks to our html5 canvas, and canvas.context.. */
  var canvas, ctx; 

  /* check if html5-canvas is supported.. */
  function canvasSupported(){
    canvas = document.getElementsByTagName("canvas")[0];
    ctx = canvas.getContext('2d');
    return( !!(ctx));
  }
   
  /* check that the prerequisites are satisfied, and set up the canvas.. */ 
  function init(){
    setDefaultData();
      
    console.log('checking prerequisites..');
    if(!hasLocalStorage()){
      alert('Error:\nHTML5:localStorage unavailable.\n\nUpdate your browser.');
      return;
    }
    if(!canvasSupported()){
      alert('Error: HTML5 canvas not supported. Please update your browser.');
      return;
    }else{
      ctx.width = 800; 
			ctx.height= canvasHeight; 
    }

    console.log('prerequisites seem to be ok..');
  };

  /* don't pass go without the canvas and localStorage.. */
  init();
  
  
 /* State variables */  //  
  gridContent = {}; 
  
 if(false){
		/* sometimes for debugging, need to clear saved state.. */
		localStorage.removeItem('gridContent');
		localStorage.removeItem('puzzlePieceData');
 } 
  /* 
  
			gridContent	<--- this variable indicates if the grid square:  
			at location:  
					'(' + i.toString() +',' + j.toString() + ')'   (***) 
      is occupied. 
      
      The variable holds a name (a number >=0) of the occupying 
      puzzle piece. If the grid location is empty, the value is 
      set to -1;
      
      gridContent maps from (***) to the index in puzzlePieceData 
			(or -1 if the square (***) is empty..)
  */
   
  puzzlePieceData = new Array( 5 * Math.ceil( ctx.width / 100) * Math.ceil( ctx.height/100));
  /* There's an arbitrary constant in the above array, 
			because when we support deleting/creating, we need to add space 
			(don't have time to implement the appropriate garbage collection 
			on this iteration... 
			
			Ideally re-use tiles without overly creating/deleting... 
  
  */
  
  for( var i=0; i<puzzlePieceData.length; i++){
    puzzlePieceData[i] = { 'text':'' } ; //let's add a 'text' property later.. and other properties. 
  }
  var nextPuzzlePieceName = 0;

  var pickThis = ''; //this gets set to a certain 'cI' if a certain grid element gets picked. 
  var selectedItem = ''; /* Something that gets picked will get selected. You can unselect it by rePicking. */
  var selectedX  = '';
  /* set up keyboard handlers, and keyboard state variables.. */
  var lastKeyPressed = ''; //track the last key pressed (onkeydown).. 

 
		
 
   /* transfer inMemory variable to localStorage.. 
   
   NB variables need to be defined at the top, for this to work..
   
   */
	function varSave(variableName){
		var myValue = eval('JSON.stringify('+variableName+');');
		localStorage.setItem(variableName, myValue);
		//eval('localStorage.setItem('+variableName+',JSON.stringify('+variableName+'));');
		//localStorage.setItem(variableName, eval('JSON.stringify('+variableName+');'));
	}
	
	/* 
			transfer localStorage version to inMemory variable (if available)..
			otherwise, initialize a new localStorage version.. 
			N.B., not really a version: more like a copy!
	
	*/
  function varInit(variableName){  /* init variable, but restore if not already defined... */
		var item = localStorage.getItem(variableName);
		if(item==null){
			/* no localStorage copy to restore-- so, write one:  */
			varSave(variableName);
			eval('console.log('+variableName+');');
			return(eval(variableName));
		}else{
		 /* restore localStorage copy. */
		  eval(variableName+' = JSON.parse(item);');
		  eval('console.log('+variableName+');');
		  return(JSON.parse(item));
		}
	}

	if(true){
		progIter = varInit('progIter');
		if(false)document.getElementById("h1").innerHTML = "Recognition Memory Experiment Framework (iter="+progIter.toString()+")";
		progIter++;
		varSave('progIter');
	}	
  
  var invColor;
  var img = new Image(); 
  img.src = 'site/uvicAerial.jpg';  
  var avgColor = [0.,0.,0.];
  
  
  function resolveColor(color){
    // return an array containing R, G and B values
    if(color === 'transparent')// IE (6 and ?)
        color = '#FFF';
    var r,g,b;
    var hex_color_pcre = new RegExp("^#[0-9a-f]{3}([0-9a-f]{3})?$",'gi');
    var rgb_color_pcre = new RegExp("rgb\\(\\s*((?:[0-2]?[0-9])?[0-9])\\s*,\\s*((?:[0-2]?[0-9])?[0-9])\\s*,\\s*((?:[0-2]?[0-9])?[0-9])\\s*\\)$",'gi');
    var rgb_percent_color_pcre = new RegExp("rgb\\(\\s*((?:[0-1]?[0-9])?[0-9])%\\s*,\\s*((?:[0-1]?[0-9])?[0-9])%\\s*,\\s*((?:[0-1]?[0-9])?[0-9])%\\s*\\)$",'gi');
    if(color.match(hex_color_pcre)){
        if(color.length == 4){
            r  = color.charAt(1)+""+color.charAt(1);
            g  = color.charAt(2)+""+color.charAt(2);
            b  = color.charAt(3)+""+color.charAt(3);
        }
        else{
            r  = color.charAt(1)+""+color.charAt(2);
            g  = color.charAt(3)+""+color.charAt(4);
            b  = color.charAt(5)+""+color.charAt(6);
        }
        r = h2d(r);
        g = h2d(g);
        b = h2d(b);
    }
    else if(color.match(rgb_color_pcre)){
        r = RegExp.$1;
        g = RegExp.$2;
        b = RegExp.$3;
    }
    else if(color.match(rgb_percent_color_pcre)){
        r = parseInt((RegExp.$1)*2.55);
        g = parseInt((RegExp.$2)*2.55);
        b = parseInt((RegExp.$3)*2.55);
    }
    else
        return false;

    /*var returned =[];
    returned['red'] = r;
    returned['green'] = g;
    returned['blue'] = b;*/
    return( 'rgb('+r.toString()+','+g.toString()+','+b.toString()+')');
//    return returned;
}


    
  function inverseColor( _rgbColor){
 
		var rgbColor = resolveColor(_rgbColor);
    /*Return the string for the complementary inverse color, 
    for a color string of the format:
      rgb(230,226,224) 
    */
    var values = (rgbColor.slice(4, rgbColor.length-1)).split(',');
    /* should now have a string array like this:
	  230,226,224  */
    var s = 'rgb(';
    for( var i=0; i<3; i++){
      s+= (255-parseInt(values[i])).toString();
      if( i<2){
				s+=',';
      }
    }
    return(s+')'); 
  }
  
  img.onload = function() {
    /* 
      When the background image loads, calculate an approximation 
	to the average colour of the image. Ideally we would use 
	an offscreen canvas or other method to do this, if we had more time.
	
	First: set the canvas size to the background image:
    */
    ctx.width = img.width; 
    ctx.height = img.height;
    
    /* 
      Draw the background image (temporarily) on the canvas. Read the data
	values back in, and sample them to get an approximate average 
	value of the colour of the background image. 
    */
    ctx.drawImage(img, 0, 0); //write bg image to the canvas. 
    var imageData = ctx.getImageData(0, 0, img.width, img.height);
    var pix = imageData.data; //read back the pixel data. 
    var nn = 0;	//count the number of points used in the sample. 
    var nSkip = 7777; 
    /* use a sample/fraction of the image data, to save time.. */
    for (var i = 0; i < pix.length; i+=4) {
      /* Use (1/nSkip) of the image pixels. */
      if( i%nSkip==0){
				var r = 1.*pix[i  ];//red
				var g = 1.*pix[i+1];//green
				var b = 1.*pix[i+2];//blue
				avgColor[0]+=r; avgColor[1]+=g; avgColor[2]+=b; 
				nn+=1.; /* keep track of the number of elements in the sample. */
			}/* Note: pix[i+3] is 'alpha' (the fourth element) */
		}
    /* divide by sample mean to get an approximation of the average: */
    avgColor[0]/=nn;avgColor[1]/=nn; avgColor[2]/=nn;
    /* calculate the inverted colour. */
    invColor = 'rgb(' 
			+(255-Math.floor(avgColor[0])).toString() +','
			+(255-Math.floor(avgColor[1])).toString() +','
			+(255-Math.floor(avgColor[2])).toString() 
			+')'; 
    avgColor = inverseColor( invColor);//represent the original in the same format. 
  } //img.onload = function() 

  ctx.width = 800; 
  ctx.height= canvasHeight;//  800; 


  
  /* convert a string of form:
	'1,2'
	
     to a pair of integers of form:
	[1,2]
  */
  function toPair( ci){
    var parts = ci.split('-');  //use - as separator for our "pair" construction. 
    for(var i=0; i<2; i++){
      parts[i]=parseInt(parts[i]);
    }
    return( parts);
  }
  
  /* 
    Disable scroll down when spacebar is pressed
  */
  window.onkeydown = function(e) { 
    return !(e.keyCode == 32);
  };

  /* Check if a string (or character) is all upper case. */
  function allUpperCase(s){
    var ss = s.toString();
    return( ss == ss.toUpperCase());
  }

  
  var shiftKey = false; 
  /*
    
  */


  


  /* set up the keyboard event handling scheme above.. */
  var keyboard = keyboard_module(testing);
  


  /* function to convert window mouse coordinates to canvas mouse coordinates. */
  function windowToCanvas(canvas, x,y){
    var bbox = canvas.getBoundingClientRect();
    return { x:(x-bbox.left)*(canvas.width/bbox.width),
       y:(y-bbox.top) *(canvas.height/bbox.height)};
    /*  
      //Example use of windowToCanvas:  
        canvas.onmousemove=function(e){
          var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        };
      //End example..
    */
  }
  
  //----------------------------------------------------------------------------
var cw=canvas.width;
var ch=canvas.height;
function reOffset(){
  var BB=canvas.getBoundingClientRect();
  offsetX=BB.left;
  offsetY=BB.top;        
}
var offsetX,offsetY;
reOffset();


function makeBeziers(s){
  var ret = ([
    {cx1:0,  cy1:15,  cx2:35,cy2:15, ex:37, ey:5},   // left shoulder
    {cx1:37, cy1:5,  cx2:40,cy2:0,  ex:38, ey:-5},  // left neck
    {cx1:38, cy1:-5, cx2:20,cy2:-20,ex:50, ey:-20}, // left head
    {cx1:50, cy1:-20,cx2:80,cy2:-20,ex:62, ey:-5},  // right head
    {cx1:62, cy1:-5, cx2:60,cy2:0,  ex:63, ey:5},   // right neck
    {cx1:63, cy1:5,  cx2:65,cy2:15, ex:100,ey:15},   // right shoulder
  ]);
  for( var i = 0; i<ret.length; i++){
     ret[i].cx1*=s;
     ret[i].cx2*=s;
     ret[i].cy1*=s;
     ret[i].cy2*=s;
     ret[i].ex*=s;
     ret[i].ey*=s;
  }
  return ret;
}


function drawUp(transX,transY, reverseDirection, pw){
  //ctx.translate(transX,transY);
  var bSet = makeBeziers(1.*(pw/100.));
  var tx  = transX; 
  var ty  = transY;
  if( reverseDirection==true){
    for(var i=bSet.length-1; i>=0; i--){
      var b=bSet[i];
      ctx.bezierCurveTo(b.ex+tx,b.ey+ty,b.cx2+tx,b.cy2+ty,b.cx1+tx,b.cy1+ty);
    }
  }else{
    for(var i=0;i<bSet.length;i++){
      var b=bSet[i];
      ctx.bezierCurveTo(b.cx1+tx,b.cy1+ty,b.cx2+tx,b.cy2+ty,b.ex+tx,b.ey+ty);
    }
  }
}
function drawLine(x,y,u,v){ //ctx.beginPath(); 
  ctx.moveTo(x,y);  
  ctx.lineTo(u,v); //ctx.closePath(); //ctx.stroke();
}

/* Draw a puzzle piece that only can have vertical connections. */
function drawPiece(aTransX,aTransY, /* <-translation offset.. */ pw,ph /* <-puzzle piece dims..*/ , isSelected, cI){ 
  
  var puzCoords = toPair( cI);
  var transX = aTransX; 
  var transY = aTransY;
   
  ctx.lineWidth=0.5;
  ctx.strokeStyle='blue';
  var sizeP = ph;//100; 
  var pp = 15 * (100./pw);
  //sizeP = 100-pp;
  /* Draw the shape (without edges). */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,transX, transY+pp);
  drawUp(transX, transY, false, pw);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawUp(transX, transY+sizeP, true, pw);//false);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.closePath();
  var myFillColor=''; 
  if( puzCoords[0]==7){
		
		myFillColor=/*ctx.fillStyle=*/ hsv2rgb((360/8.)*((puzCoords[1]+3)),1,1);
		(puzzlePieceData[gridContent[cI]])['color']=myFillColor;
		
		function assignTypeString(val) {
			var answer = "";
			switch( val ) {
			case 0: 
				return("INSTRUCTIONS");
				break;
			case 1: 
				return("RESPONSE");
				break;
			case 2: 
				return("DELAY");
				break;
			case 3: 
				return("STUDY-PHASE");
				break;
			case 4: 
				return("TEST-PHASE");
				break;
			Default:
				return(null);//answer = "Massive or Tiny?";
			} 
			return answer;  
		}
		if( puzCoords[1] <=4 ){
			/* this is "the assignment bit".... 
			
				So, if the type is to be, TEST-PHASE,
				
				we need to confirm
					1) that there is a STUDY-PHASE unit in the square above... 
							and
					2) that we can assign the above STUDY-PHASE id, to the TEST-PHASE....
					
					3) when we SELECT an item, we need to make sure the 
						selectedItem basically points to the STUDY-PHASE unit, in both cases... 
						
						if there is no study phase in the square above, don't allow the assignment. 
						
			*/
			
			var typeToAssign = assignTypeString(puzCoords[1]);
			/* */
			if(  typeToAssign == "TEST-PHASE" ){
			  scI = (puzCoords[0]).toString()+'-'+(puzCoords[1]-1).toString();
			  //console.log('scI',scI);
				if( gridContent[scI]!=null && ((puzzlePieceData[gridContent[scI]])['type']=="STUDY-PHASE") ){
					(puzzlePieceData[gridContent[cI]])['type']=typeToAssign;
					/*
							now need to assign the STUDY-PHASE name-id (not grid square id) to this one...
					*/
					(puzzlePieceData[gridContent[cI]])['master']=gridContent[scI];
				}else{
					console.log('nothing there.');
				}
			}else{
				(puzzlePieceData[gridContent[cI]])['type']=typeToAssign;
				delete (puzzlePieceData[gridContent[cI]])['master'];
				
			}//(puzzlePieceData[gridContent[cI]])['type']=typeToAssign;
		}
		else{
			(puzzlePieceData[gridContent[cI]])['type']=null;//assignTypeString(puzCoords[1]);
			myFillColor=/*ctx.fillStyle=*/ (isSelected==true)?avgColor:invColor;//inverseColor(invColor);
			(puzzlePieceData[gridContent[cI]])['color']=invColor;
			
		}
		
  }else{
		myFillColor=/*ctx.fillStyle=*/ (isSelected==true)?avgColor:invColor;//inverseColor(invColor);
		var savedColor =(puzzlePieceData[gridContent[cI]])['color'];
		if( savedColor){
		
			if(  ((savedColor.toString())[0])=='#'){
				savedColor = hexToRgb( savedColor);
				(puzzlePieceData[gridContent[cI]])['color'] = savedColor;
			}
		}
		//console.log('savedColor', savedColor);
		if(savedColor ){

			myFillColor=(isSelected==true)?inverseColor(savedColor):savedColor;
		}
	} 
	ctx.fillStyle=myFillColor;

  ctx.fill();
  
  /* draw the picking area.. MAYBE only draw this when the piece is highlighted!!! */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,   transX, transY+pp);
  drawLine(     transX, transY+pp,transX+pw, transY+pp);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawLine(  transX+pw, transY+sizeP+pp,transX, transY+sizeP+pp);
  ctx.closePath();
  ctx.strokeStyle='green';
  ctx.stroke();
  
  var fontSize = 11;
  /* Now, draw the text content..  */
  function wrapText(str, startY, isSelected, isBold){  //with some help from ashblue
    var words = str.split(" ");
    var myX = 10;
    var myY = 50;
    var line = '';
    var lines = [ ] ;
    var lineTest = '';
    
    ctx.font = fontSize +"px Arial";
    if(isBold){
			ctx.font = "Bold Italic "+ctx.font;
    }
    ctx.fillStyle = (isSelected)?invColor:avgColor;
    try{
			//ctx.fillStyle = (isSelected)?inverseColor(myFillColor):myFillColor;//invColor:avgColor;//'blue';
    }catch(e){
			ctx.fillStyle = (isSelected)?invColor:avgColor;
    }
    for(var j=0; j<words.length; j++){
      lineTest = line + words[j] + ' ';
      if( ctx.measureText(lineTest).width > 100){
				myY = lines.length * fontSize + fontSize;
				lines.push( {text: line, height: myY});
				line = words[j] + ' ';
      }else{
				line = lineTest; 
      }        
    } 
    // Catch last line in-case something is left over
    if (line.length > 0) {
      currentY = lines.length * fontSize + fontSize;
      lines.push({ text: line.trim(), height: currentY });
    }   
    // Visually output text
    //ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var j = 0, len = lines.length; j < len; j++) {
      ctx.fillText(lines[j].text, transX, lines[j].height+ startY);
    }
  }
  var myString = (puzzlePieceData[gridContent[cI]])['text'];
  var myType = (puzzlePieceData[gridContent[cI]])['type'];
  if( myType ){
		wrapText( myType.toString()+":", transY+15, isSelected, true);
		wrapText( myString, fontSize+transY+15, isSelected,false); 
  }else{
		wrapText( myString, +transY+15, isSelected,false); 
  }
  
  
  
}



/*
  Draw the grid. 
  
  Also, (for now), randomly initialize (empty) puzzle piece
    elements on the grid. 
*/
function drawGrid(cw, ch){
  /*
     Draw the grid. 
  */
  var v = 36;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth=1;
  ctx.strokeStyle='blue';
  ctx.setLineDash([5, 15]);
  for( var i=0; i<cw/100; i++){
    drawLine( i * 100, 0+v, i*100, ch+v);    ctx.stroke();
  }
  for(var j=0; j<ch/100; j++){
    drawLine(0, j*100+v, cw, j*100+v);     ctx.stroke();
  }
  
  /* Randomly initialize puzzle piece elements on the grid (for now).. 
	Change this later.. 
  */
  if( progIter<1){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
				//pass
      }else{
				if( Math.random()<.4){////if( i%3==0 || j%==0){
					gridContent[cI]=(nextPuzzlePieceName++);
				}else{
					gridContent[cI]=-1;
				}
      }
    }
  }
 }
 ctx.globalAlpha = 1.;
}

/*
  Draw the puzzle pieces on the grid. 
*/
function drawGridContent(){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
	if(gridContent[cI]>=0){
	  if( pickThis == cI){
	    /* Mouse motion: puzzle piece follows mouse coordiantes: */
	    drawPiece(mx, my, 100,100, cI==selectedItem, cI);
				//0 + 100*i,21 + 100*j, 100,100);
	  }else{
	     //Puzzle piece is static: 
	    drawPiece(0 + 100*i,21 + 100*j, 100,100, cI==selectedItem, cI);
	  }
	      //draw(mx, my, 100, 100);
	}
      }
    }
  }
}


var w = 800;//window.innerWidth-20;
var h = canvasHeight;//800;//window.innerHeight-20; 
drawGrid(w,h);
drawGridContent();

/*
	This comment used to read
	"Before drawing or initializing the grid, try to restore it:"
	
	.. but now, we need to adjust that statement, because we would like to 
		initialize the variables schema, in order to dump data into them.. 
*/
if(progIter>0){
	varInit('gridContent');
	varInit('puzzlePieceData');   //next, use JSON.stringify() and JSON.parse()
	/*
		progIter = varInit('progIter');
		document.getElementById("h1").innerHTML = "Recognition Memory Experiment Framework (iter="+progIter.toString()+")";
		progIter++;
		varSave('progIter');
	*/	
}
//----------------------------------------------

 /* Global variables to track animation loop.. */
  var i=0; //loop iteration counter. 
  var movingAverage = 0.; //moving average for fps calc... 
  var t0 = window.performance.now(); //start time..
  var t2 = 0; var t1=t0; //times used in loop..
  
  
  var mx, my; mx=my=0;

  /* function to execute, animation loop.. */
  function frame(){
    //document.bgColor = "#FFFFFF"; //"#000000"

    var w = 800;//window.innerWidth-20;
    var h = canvasHeight;//800;//window.innerHeight-20; 
    /* set the canvas size dynamically so that the software is device independent and so on... */    
    canvas.width  = w;
    canvas.height = h;


    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    
    /* Image scaling approach for logo (right corner) */
    /*
    ctx.save();
      ctx.globalAlpha = 1.0;
      var lW = logoImg.width; var lH = logoImg.height;
      var wf = (w-20)/(5. * lW);
      ctx.drawImage( logoImg, w-(lW*wf),h-(lH*wf),lW*wf, lH*wf);
    ctx.restore();
    */
    
    drawGrid(w,h);
    drawGridContent();
  
    /*loop profiling section */
    var t2 = window.performance.now()
    if( i==1){
      movingAverage = t1 - t0;
    }else{
      movingAverage = (movingAverage +(t2-t1))/2.;
    }
    t1 = t2; 
    if (i % 1000 == 0) {
      console.log(movingAverage.toString()+(' mS = ')+((1./(movingAverage/1000.)))+(' fpS'));
    }
    /* Total time elapsed since start.. */
    var timeElapsed = Math.ceil(( t1-t0)/1000.);  i += 1;
    if(false){
      /* print out DOM element names... 
      
	 Was looking to see if generally there was a pattern, 
	  the two methods for exploring the DOM don't seem 
	  to give the same results. 
      */
      var all = document.getElementsByTagName("*");
      for (var i=0, max=all.length; i < max; i++) {
	// Do something with the element here	
	console.log( all[i].toString() + ' i='+ i.toString());
      }

      var currentNode,
      ni = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_ELEMENT);

      while(currentNode = ni.nextNode()) {
				console.log(currentNode.nodeName);
      }
    }
    
			if( localStorage.getItem( 'gridContent')==null ){
				/* break out of the loop if we have cleared localStorage..*/
				//alert('localStorage not available.');
				//throw '';
				console.log('clearInterval.');
				
				clearInterval(refreshId);
				
			}else{
				varSave('gridContent');
				varSave('puzzlePieceData');
			}
  };
  
  /* Mouse button down event */
  canvas.addEventListener("mousedown", function(e){  /* e.clientX, e.clientY */
    /* mouse down event listener code... */ 
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    var cw = canvas.width;
    var ch = canvas.height;
    var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
    /* Did we click on a 'valid' grid square? */
    if( cI in gridContent){
      pickThis = cI; 
      /* was this item already selected? */
      if( selectedItem ==cI){
				/* If the picked item was already selected, unselect it. */
				selectedItem = '';
			}else{
				/* If the picked item was not already selected, select it! */
				selectedItem = cI;
				try{
					/* log the colour of the selected item (if something is selected)... */
					var selectedItemColor = (puzzlePieceData[gridContent[cI]])['color'];
					if(selectedItemColor!=null){
						console.log('selectedItem.color:',selectedItemColor,' selectedItem ',selectedItem);
						try{ 
							console.log( 'master: ',puzzlePieceData[gridContent[selectedItem]]['master'] );
						}catch(e){
						}
					}
				}catch(e){
				}
				/* Track the starting mouse position for the selection 
					.. the idea was to use this as an "offset", later. 
				*/
				selectedX = [mx, my]; 
      }
    }
    
  });

  /* Mouse up event.. */
  canvas.addEventListener("mouseup", function(e){  /* e.clientX, e.clientY */
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    if( pickThis!=''){
      var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
      if( cI in gridContent){
	if( gridContent[cI]<0 /*==''*/ /* only move to empty space*/ 
	    && (cI!=pickThis)  /* if dest=src then don't move!!!!..  */ ){
	  plopSound.play();
	  console.log('Overwriting '+cI+' with '+pickThis+ ' puzzlePieceName=' 
	    +(gridContent[pickThis]).toString());
	  gridContent[cI]=gridContent[pickThis];
	  gridContent[pickThis]=-1;//'';
	}
      }
    }
    /* keep the status quo. */
    pickThis ='';
  });
  
  canvas.onmousemove=function(e){
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    return;
    console.log(
	'x '+(e.clientX).toString()+' y '+(e.clientY).toString()
      + ' cx '+(loc.x).toString()
      + ' cy '+(loc.y).toString()
      + ' i  '+Math.floor(loc.x / 100).toString()
      + ' j  '+Math.floor(loc.y / 100).toString()
      );
  };


  
</script>
<script src="startEventLoop.js"></script>
</body>
</html>
