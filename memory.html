<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

<head>
  <link rel="stylesheet" href="main.css"> 
  <title>Recognition Memory Experiment Framework</title>
  <img src="uvicSmall.png" >
  <h1>Recognition Memory Experiment Framework</h1>
</head>

<body>
<canvas id="canvasID" width="800" height="800">Error: HTML5 canvas unupported.</canvas>
<script>  
  var plopSound = new Audio('plop.mp3'); //  plopSound.play();
  /* check if localStorage is supported.. */
  function hasLocalStorage(){ 
    var test = 'test';
    try{
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    }catch(e){
      return(false);
    }
  }
  /* Persistent variables schema..  
      Persistent variables stored in string format. 
      When initialized, if direct conversion to INT possible, 
      perform that conversion!!!!!
      
      Add method for assigment (that does the "backup"). 
  
 
Supported Schema:
	var nextPuzzlePieceName = 0; 	      	(simple) 
   	var gridContent = { } ;  	   	(dict) 
   	puzzlePieceData[i] = { 'text':'' } ;  	(array of dict) 
   	
   	We'll use a character that isn't on the keyboard for our separator, 
   	- need a data separator: ♠
   	- need a special separator for our "pair" expressions: ♥  
   	
   	
   	Object.keys( gridContent)
	["0♥0", "0♥1", "0♥2", "0♥3", "0♥4", "0♥5", "0♥6", "0♥7", "0♥8", "1♥0", "1♥1", "1♥2", "1♥3", "1♥4", "1♥5", "1♥6", "1♥7", "1♥8", "2♥0", "2♥1", "2♥2", "2♥3", "2♥4", "2♥5", "2♥6", "2♥7", "2♥8", "3♥0", "3♥1", "3♥2", "3♥3", "3♥4", "3♥5", "3♥6", "3♥7", "3♥8", "4♥0", "4♥1", "4♥2", "4♥3", "4♥4", "4♥5", "4♥6", "4♥7", "4♥8", "5♥0", "5♥1", "5♥2", "5♥3", "5♥4", "5♥5", "5♥6", "5♥7", "5♥8", "6♥0", "6♥1", "6♥2", "6♥3", "6♥4", "6♥5", "6♥6", "6♥7", "6♥8", "7♥0", "7♥1", "7♥2", "7♥3", "7♥4", "7♥5", "7♥6", "7♥7", "7♥8", "8♥0", "8♥1", "8♥2", "8♥3", "8♥4", "8♥5", "8♥6", "8♥7", "8♥8"]

 
	Object.keys(puzzlePieceData)
	["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63"]
 */
 
 
  /* keep hooks to our html5 canvas, and canvas.context.. */
  var canvas, ctx; 

  /* check if html5-canvas is supported.. */
  function canvasSupported(){
    canvas = document.getElementsByTagName("canvas")[0];
    ctx = canvas.getContext('2d');
    return( !!(ctx));
  }
   
  /* check that the prerequisites are satisfied, and set up the canvas.. */ 
  function init(){
    console.log('checking prerequisites..');
    if(!hasLocalStorage()){
      alert('Error:\nHTML5:localStorage unavailable.\n\nUpdate your browser.');
      return;
    }
    if(!canvasSupported()){
      alert('Error: HTML5 canvas not supported. Please update your browser.');
      return;
    }
    console.log('prerequisites seem to be ok..');
  };

  /* don't pass go without the canvas and localStorage.. */
  init();
  var invColor;
  var img = new Image(); 
  img.src = 'http://web.uvic.ca/~ashy/memory/uvicAerial.jpg';
  var avgColor = [0.,0.,0.];
  
    
  function inverseColor( rgbColor){
    /*Return the string for the complementary inverse color, 
    for a color string of the format:
      rgb(230,226,224)
    */
    var values = (rgbColor.slice(4, rgbColor.length-1)).split(',');
    /* should now have a string array like this:
	  230,226,224  */
    var s = 'rgb(';
    for( var i=0; i<3; i++){
      s+= (255-parseInt(values[i])).toString();
      if( i<2){
	s+=',';
      }
    }
    return(s+')'); 
  }
  
  img.onload = function() {
    /* 
      When the background image loads, calculate an approximation 
	to the average colour of the image. Ideally we would use 
	an offscreen canvas or other method to do this, if we had more time.
	
	First: set the canvas size to the background image:
    */
    ctx.width = img.width; 
    ctx.height = img.height;
    
    /* 
      Draw the background image (temporarily) on the canvas. Read the data
	values back in, and sample them to get an approximate average 
	value of the colour of the background image. 
    */
    ctx.drawImage(img, 0, 0); //write bg image to the canvas. 
    var imageData = ctx.getImageData(0, 0, img.width, img.height);
    var pix = imageData.data; //read back the pixel data. 
    var nn = 0;	//count the number of points used in the sample. 
    var nSkip = 7777; 
    /* use a sample/fraction of the image data, to save time.. */
    for (var i = 0; i < pix.length; i+=4) {
      /* Use (1/nSkip) of the image pixels. */
      if( i%nSkip==0){
	var r = 1.*pix[i  ];//red
	var g = 1.*pix[i+1];//green
	var b = 1.*pix[i+2];//blue
	avgColor[0]+=r; avgColor[1]+=g; avgColor[2]+=b; 
	nn+=1.; /* keep track of the number of elements in the sample. */
      }/* Note: pix[i+3] is 'alpha' (the fourth element) */
    }
    /* divide by sample mean to get an approximation of the average: */
    avgColor[0]/=nn;avgColor[1]/=nn; avgColor[2]/=nn;
    /* calculate the inverted colour. */
    invColor = 'rgb(' 
		+(255-Math.floor(avgColor[0])).toString() +','
		+(255-Math.floor(avgColor[1])).toString() +','
		+(255-Math.floor(avgColor[2])).toString() 
		+')'; 
    avgColor = inverseColor( invColor);//represent the original in the same format. 
  }

  ctx.width = 800; 
  ctx.height= 800; 

  /* State variables */  //  
  var gridContent = { } ;   /* 	<--- Variable indicating if the grid square:  
	at location:  '(' + i.toString() +',' + j.toString() + ')'   (***) 
      is occupied. 
      
      The variable holds a name (a number >=0) of the occupying 
      puzzle piece. If the grid location is empty, the value is set to -1;
      
      gridContent maps from (***) to the index in puzzlePieceData 
	(or -1 if the square (***) is empty..)
  */
   
  var puzzlePieceData = new Array( Math.ceil( ctx.width / 100) * Math.ceil( ctx.height/100));
  for( var i=0; i<puzzlePieceData.length; i++){
    puzzlePieceData[i] = { 'text':'' } ; //let's add a 'text' property later.. and other properties. 
  }
  var nextPuzzlePieceName = 0;

  var pickThis = ''; //this gets set to a certain 'cI' if a certain grid element gets picked. 
  var selectedItem = ''; /* Something that gets picked will get selected. You can unselect it by rePicking. */
  var selectedX  = '';
  /* set up keyboard handlers, and keyboard state variables.. */
  var lastKeyPressed = ''; //track the last key pressed (onkeydown).. 
  
  /* convert a string of form:
	'1,2'
	
     to a pair of integers of form:
	[1,2]
  */
  function toPair( ci){
    var parts = ci.split('♥');  //use ♥ as separator for our "pair" construction. 
    for(var i=0; i<2; i++){
      parts[i]=parseInt(parts[i]);
    }
    return( parts);
  }
  
  /* 
    Disable scroll down when spacebar is pressed
  */
  window.onkeydown = function(e) { 
    return !(e.keyCode == 32);
  };

  /* Check if a string (or character) is all upper case. */
  function allUpperCase(s){
    var ss = s.toString();
    return( ss == ss.toUpperCase());
  }

  
  var shiftKey = false; 
  /*
    
  */


  
  function keyboard_module(onUpdate) {
    var kb = {};
    var unicode_mapping = {};
    /* handler for key down event.. override automatic key repeats!
    
	With the exception of BACKSPACE.. !!!
    */
    document.onkeydown = function(e) {
      //console.log( 'key code: '+ (e.keyCode).toString()+ ' charCode: '+(e.charCode).toString()); 
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      if(lastKeyPressed!='' && (lastKeyPressed==key) && ( unicode!=8)){
        return;
      }
      console.log('unicode: ',unicode)
      lastKeyPressed =key;
      kb[key] = true;
      if (onUpdate) {
        onUpdate(kb);//alert(key);
      }
      if( unicode ==16){
	shiftKey =true; 
      }
      if( selectedItem!=''){
	//console.log('Selected item!!!!');
	var myName = gridContent[ selectedItem];
	var curText = (puzzlePieceData[myName])['text'];
        var newValue = String.fromCharCode(unicode);
	if( unicode==8){
	  /* backSpace (need to add other 'control' characters..) */
	  if( curText.length >1){
	    curText = curText.slice(0, curText.length-1);
	  }
	}else{
	  //var gridCoords = toPair( selectedItem);

	  if( unicode ==13){
	    newValue = '\n';
	    /* right now enter doesn't effectively do anything. 
		(would have to modify the wrapText method). 
	    */
	  }
	  function reMap(u,newVal, shiftVal){
	    var ret = newValue; 
	    if(unicode==u){
	      ret = newVal; 
	      if(shiftKey){
		ret = shiftVal; 
	      }
	    }return(ret);
	  }
	  newValue= reMap(190,  '.',  '>');
	  newValue= reMap(188,  ',',  '<'); //might need to  
	  newValue= reMap(186,  ';',  ':');
	  newValue= reMap(222,  "'",  '"');
	  newValue= reMap(191,  '/',  '?');
	  newValue= reMap(219,  '[',  '{');
	  newValue= reMap(221,  ']',  '}');
	  newValue= reMap(220,  "\\", '|'); //might need to disable backslash later. 
	  newValue= reMap(221,  ']',  '}');
 	  newValue= reMap(192,  '`',  '~');
	  newValue= reMap( 49,  '1',  '!');
  	  newValue= reMap( 50,  '2',  '@');    
 	  newValue= reMap( 51,  '3',  '#');
 	  newValue= reMap( 52,  '4',  '$');
 	  newValue= reMap( 53,  '5',  '%');
 	  newValue= reMap( 54,  '6',  '^');
 	  newValue= reMap( 55,  '7',  '&');
 	  newValue= reMap( 56,  '8',  '*');
 	  newValue= reMap( 57,  '9',  '(');
 	  newValue= reMap( 48,  '0',  ')');
 	  newValue= reMap(189,  '-',  '_');
 	  newValue= reMap(187,  '=',  '+');
	  if( shiftKey ){
	    newValue = (newValue.toString()).toUpperCase();
	  }else{
	    newValue = (newValue.toString()).toLowerCase();
	  }
	  curText+= newValue.toString(); //unicode.toString();
	}
	(puzzlePieceData[myName])['text']=curText;
      }
    }
    /* handler for key up event.. */
    document.onkeyup = function(e) {
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      lastKeyPressed = '';
      delete kb[key];
      if (onUpdate) {
        onUpdate(kb);
      }

       if( unicode ==16){
	shiftKey =false; 
      }
    }
    /* function to check the keyboard state.. */
    function getKey(unicode) {
      if (unicode_mapping[unicode]) {
        var key = unicode_mapping[unicode];
      } else {
        var key = unicode_mapping[unicode] = String.fromCharCode(unicode);
      }
      return key;
    }
    return kb;
  }/* function keyboard_module(onUpdate).. keyboard handler..  */

  /* by default, log which keys are currently down.. */
  function testing(kb) {
    console.log('These keys are down: ', kb); //These keys are down:  Object {S: true} //e.g., for S pressed... 
  }

  /* set up the keyboard event handling scheme above.. */
  var keyboard = keyboard_module(testing);
  


  /* function to convert window mouse coordinates to canvas mouse coordinates. */
  function windowToCanvas(canvas, x,y){
    var bbox = canvas.getBoundingClientRect();
    return { x:(x-bbox.left)*(canvas.width/bbox.width),
       y:(y-bbox.top) *(canvas.height/bbox.height)};
    /*  
      //Example use of windowToCanvas:  
        canvas.onmousemove=function(e){
          var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        };
      //End example..
    */
  }
  
  //----------------------------------------------------------------------------
var cw=canvas.width;
var ch=canvas.height;
function reOffset(){
  var BB=canvas.getBoundingClientRect();
  offsetX=BB.left;
  offsetY=BB.top;        
}
var offsetX,offsetY;
reOffset();


function makeBeziers(s){
  var ret = ([
    {cx1:0,  cy1:15,  cx2:35,cy2:15, ex:37, ey:5},   // left shoulder
    {cx1:37, cy1:5,  cx2:40,cy2:0,  ex:38, ey:-5},  // left neck
    {cx1:38, cy1:-5, cx2:20,cy2:-20,ex:50, ey:-20}, // left head
    {cx1:50, cy1:-20,cx2:80,cy2:-20,ex:62, ey:-5},  // right head
    {cx1:62, cy1:-5, cx2:60,cy2:0,  ex:63, ey:5},   // right neck
    {cx1:63, cy1:5,  cx2:65,cy2:15, ex:100,ey:15},   // right shoulder
  ]);
  for( var i = 0; i<ret.length; i++){
     ret[i].cx1*=s;
     ret[i].cx2*=s;
     ret[i].cy1*=s;
     ret[i].cy2*=s;
     ret[i].ex*=s;
     ret[i].ey*=s;
  }
  return ret;
}


function drawUp(transX,transY, reverseDirection, pw){
  //ctx.translate(transX,transY);
  var bSet = makeBeziers(1.*(pw/100.));
  var tx  = transX; 
  var ty  = transY;
  if( reverseDirection==true){
    for(var i=bSet.length-1; i>=0; i--){
      var b=bSet[i];
      ctx.bezierCurveTo(b.ex+tx,b.ey+ty,b.cx2+tx,b.cy2+ty,b.cx1+tx,b.cy1+ty);
    }
  }else{
    for(var i=0;i<bSet.length;i++){
      var b=bSet[i];
      ctx.bezierCurveTo(b.cx1+tx,b.cy1+ty,b.cx2+tx,b.cy2+ty,b.ex+tx,b.ey+ty);
    }
  }
}
function drawLine(x,y,u,v){ //ctx.beginPath(); 
  ctx.moveTo(x,y);  
  ctx.lineTo(u,v); //ctx.closePath(); //ctx.stroke();
}

/* Draw a puzzle piece that only can have vertical connections. */
function drawPiece(aTransX,aTransY, /* <-translation offset.. */ pw,ph /* <-puzzle piece dims..*/ , isSelected, cI){ 
  
  
  var transX = aTransX; 
  var transY = aTransY;
  
  /*if(isSelected){
    var parts = selectedItem.split(',');
    transX -=( selectedX[0] - 100*parseInt(parts[0]));
    transY -=( selectedX[1] - 100*parseInt(parts[1]));
  }
  */
  
  ctx.lineWidth=0.5;
  ctx.strokeStyle='blue';
  var sizeP = ph;//100; 
  var pp = 15 * (100./pw);
  //sizeP = 100-pp;
  /* Draw the shape (without edges). */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,transX, transY+pp);
  drawUp(transX, transY, false, pw);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawUp(transX, transY+sizeP, true, pw);//false);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.closePath();
  if( isSelected==true){
    ctx.fillStyle = avgColor;//inverseColor(invColor);
  }else{
    ctx.fillStyle =invColor;//'#8ED6FF';
   }
  //console.log(invColor, inverseColor(invColor));
  ctx.fill();
  
  /* draw the picking area.. MAYBE only draw this when the piece is highlighted!!! */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,   transX, transY+pp);
  drawLine(     transX, transY+pp,transX+pw, transY+pp);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawLine(  transX+pw, transY+sizeP+pp,transX, transY+sizeP+pp);
  ctx.closePath();
  ctx.strokeStyle='green';
  ctx.stroke();
  
  /* Now, draw the text content..  */
  function wrapText(str, startY, isSelected){  //with some help from ashblue
    var words = str.split(" ");
    var myX = 10;
    var myY = 50;
    var line = '';
    var lines = [ ] ;
    var lineTest = '';
    var fontSize = 11;
    ctx.font = fontSize +"px Arial";
    ctx.fillStyle = isSelected?invColor:avgColor;//'blue';
    
    for(var j=0; j<words.length; j++){
      lineTest = line + words[j] + ' ';
      if( ctx.measureText(lineTest).width > 100){
	myY = lines.length * fontSize + fontSize;
	lines.push( {text: line, height: myY});
	line = words[j] + ' ';
      }else{
	line = lineTest; 
      }        
    } 
    // Catch last line in-case something is left over
    if (line.length > 0) {
      currentY = lines.length * fontSize + fontSize;
      lines.push({ text: line.trim(), height: currentY });
    }   
    // Visually output text
    //ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var j = 0, len = lines.length; j < len; j++) {
      ctx.fillText(lines[j].text, transX, lines[j].height+ startY);
    }
  }
  var myString = /*(gridContent[cI].toString())+':'+*/ (puzzlePieceData[gridContent[cI]])['text'];
  wrapText( myString, transY+15, isSelected); 
  
  
}


/*
  Draw the grid. 
  
  Also, (for now), randomly initialize (empty) puzzle piece
    elements on the grid. 
*/
function drawGrid(cw, ch){
  /*
     Draw the grid. 
  */
  var v = 36;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth=1;
  ctx.strokeStyle='blue';
  ctx.setLineDash([5, 15]);
  for( var i=0; i<cw/100; i++){
    drawLine( i * 100, 0+v, i*100, ch+v);    ctx.stroke();
  }
  for(var j=0; j<ch/100; j++){
    drawLine(0, j*100+v, cw, j*100+v);     ctx.stroke();
  }
  
  /* Randomly initialize puzzle piece elements on the grid (for now).. 
	Change this later.. 
  */
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'♥'+j.toString();
      if( cI in gridContent){
	//pass
      }else{
	if( Math.random()<.4){////if( i%3==0 || j%==0){
	  gridContent[cI]=(nextPuzzlePieceName++);
	}else{
	  gridContent[cI]=-1;
	}
      }
    }
  }
 ctx.globalAlpha = 1.;
}

/*
  Draw the puzzle pieces on the grid. 
*/
function drawGridContent(){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'♥'+j.toString();
      if( cI in gridContent){
	if(gridContent[cI]>=0){
	  if( pickThis == cI){
	    /* Mouse motion: puzzle piece follows mouse coordiantes: */
	    drawPiece(mx, my, 100,100, cI==selectedItem, cI);//0 + 100*i,21 + 100*j, 100,100);
	  }else{
	     //Puzzle piece is static: 
	    drawPiece(0 + 100*i,21 + 100*j, 100,100, cI==selectedItem, cI);
	  }
	      //draw(mx, my, 100, 100);
	}
      }
    }
  }
}

//----------------------------------------------

 /* Global variables to track animation loop.. */
  var i=0; //loop iteration counter. 
  var movingAverage = 0.; //moving average for fps calc... 
  var t0 = window.performance.now(); //start time..
  var t2 = 0; var t1=t0; //times used in loop..
  
  
  var mx, my; mx=my=0;

  /* function to execute, animation loop.. */
  function frame(){
    //document.bgColor = "#FFFFFF"; //"#000000"

    var w = 800;//window.innerWidth-20;
    var h = 800;//window.innerHeight-20; 
    /* set the canvas size dynamically so that the software is device independent and so on... */    
    canvas.width  = w;
    canvas.height = h;


    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    
    /* Image scaling approach for logo (right corner) */
    /*
    ctx.save();
      ctx.globalAlpha = 1.0;
      var lW = logoImg.width; var lH = logoImg.height;
      var wf = (w-20)/(5. * lW);
      ctx.drawImage( logoImg, w-(lW*wf),h-(lH*wf),lW*wf, lH*wf);
    ctx.restore();
    */
    
    drawGrid(w,h);
    drawGridContent();
  
    /*loop profiling section */
    var t2 = window.performance.now()
    if( i==1){
      movingAverage = t1 - t0;
    }else{
      movingAverage = (movingAverage +(t2-t1))/2.;
    }
    t1 = t2; 
    if (i % 1000 == 0) {
      console.log(movingAverage.toString()+(' mS = ')+((1./(movingAverage/1000.)))+(' fpS'));
    }
    /* Total time elapsed since start.. */
    var timeElapsed = Math.ceil(( t1-t0)/1000.);  i += 1;
    if(false){
      /* print out DOM element names... 
      
	 Was looking to see if generally there was a pattern, 
	  the two methods for exploring the DOM don't seem 
	  to give the same results. 
      */
      var all = document.getElementsByTagName("*");
      for (var i=0, max=all.length; i < max; i++) {
	// Do something with the element here	
	console.log( all[i].toString() + ' i='+ i.toString());
      }

      var currentNode,
      ni = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_ELEMENT);

      while(currentNode = ni.nextNode()) {
	console.log(currentNode.nodeName);
      }
    }
  };
  
  /* Mouse button down event */
   canvas.addEventListener("mousedown", function(e){  /* e.clientX, e.clientY */
    /* mouse down event listener code... */ 
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    var cw = canvas.width;
    var ch = canvas.height;
    var cI = Math.floor( mx / 100)+'♥'+ Math.floor( my/100); 
    /* Did we click on a 'valid' grid square? */
    if( cI in gridContent){
      pickThis = cI; 
      /* was this item already selected? */
      if( selectedItem ==cI){
	/* If the picked item was already selected, unselect it. */
	selectedItem = '';
      }else{
	/* If the picked item was not already selected, select it! */
	selectedItem = cI;
	/* Track the starting mouse position for the selection 
	    .. the idea was to use this as an "offset", later. 
	*/
	selectedX = [mx, my]; 
      }
    }
    
  });

  /* Mouse up event.. */
  canvas.addEventListener("mouseup", function(e){  /* e.clientX, e.clientY */
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    if( pickThis!=''){
      var cI = Math.floor( mx / 100)+'♥'+ Math.floor( my/100); 
      if( cI in gridContent){
	if( gridContent[cI]<0 /*==''*/ /* only move to empty space*/ 
	    && (cI!=pickThis)  /* if dest=src then don't move!!!!..  */ ){
	  plopSound.play();
	  console.log('Overwriting '+cI+' with '+pickThis+ ' puzzlePieceName=' 
	    +(gridContent[pickThis]).toString());
	  gridContent[cI]=gridContent[pickThis];
	  gridContent[pickThis]=-1;//'';
	}
      }
    }
    /* keep the status quo. */
    pickThis ='';
  });
  
  canvas.onmousemove=function(e){
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    return;
    console.log(
	'x '+(e.clientX).toString()+' y '+(e.clientY).toString()
      + ' cx '+(loc.x).toString()
      + ' cy '+(loc.y).toString()
      + ' i  '+Math.floor(loc.x / 100).toString()
      + ' j  '+Math.floor(loc.y / 100).toString()
      );
  };

  /* this command actually starts the animation-loop:.. */
  var id = setInterval(frame, 55);  //Can reduce this number to decrease latency..  
  
</script>
</body>
</html>
