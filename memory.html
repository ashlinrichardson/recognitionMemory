<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

<head>
  <link rel="stylesheet" href="main.css"> 
  <title>Recognition Memory Experiment Framework</title>
  <img src="uvicSmall.png" >
  <h1 id="h1">Recognition Memory Experiment Framework</h1>
</head>

<body>
<canvas id="canvasID" width="800" height="800">Error: HTML5 canvas unupported.</canvas>
<script>  
  var plopSound = new Audio('plop.mp3'); //  plopSound.play();
  /* check if localStorage is supported.. 
  
	  -Each Storage object provides access to a list of key/value pairs, which are sometimes called items. Keys are strings. Any string (including the empty string) is a valid key. Values are similarly strings.
	  -Each Storage object is associated with a list of key/value pairs when it is created, as defined in the sections on the sessionStorage and localStorage attributes. Multiple separate objects implementing the Storage interface can all be associated with the same list of key/value pairs simultaneously.
	  -The length attribute must return the number of key/value pairs currently present in the list associated with the object.
	  -The key(n) method must return the name of the nth key in the list. The order of keys is user-agent defined, but must be consistent within an object so long as the number of keys doesn't change. (Thus, adding or removing a key may change the order of the keys, but merely changing the value of an existing key must not.) If n is greater than or equal to the number of key/value pairs in the object, then this method must return null.
	  -The supported property names on a Storage object are the keys of each key/value pair currently present in the list associated with the object, in the order that the keys were last added to the storage area.
	  -The getItem(key) method must return the current value associated with the given key. If the given key does not exist in the list associated with the object then this method must return null.
	  -The setItem(key, value) method must first check if a key/value pair with the given key already exists in the list associated with the object.
	  -If it does not, then a new key/value pair must be added to the list, with the given key and with its value set to value.
	  -If the given key does exist in the list, and its value is not equal to value, then it must have its value updated to value. If its previous value is equal to value, then the method must do nothing.
	  -If it couldn't set the new value, the method must throw a "QuotaExceededError" DOMException exception. (Setting could fail if, e.g., the user has disabled storage for the site, or if the quota has been exceeded.)
	  -The removeItem(key) method must cause the key/value pair with the given key to be removed from the list associated with the object, if it exists. If no item with that key exists, the method must do nothing.
	  -The setItem() and removeItem() methods must be atomic with respect to failure. In the case of failure, the method does nothing. That is, changes to the data storage area must either be successful, or the data storage area must not be changed at all.
	  -The clear() method must atomically cause the list associated with the object to be emptied of all key/value pairs, if there are any. If there are none, then the method must do nothing.
	  -When the setItem(), removeItem(), and clear() methods are invoked, events are fired on the Window objects of other Documents that can access the newly stored or removed data, as defined in the sections on the sessionStorage and localStorage attributes.
  
  */
  function hasLocalStorage(){ 
    var test = 'test';
    try{
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    }catch(e){
      return(false);
    }
  }
 
  /* keep hooks to our html5 canvas, and canvas.context.. */
  var canvas, ctx; 

  /* check if html5-canvas is supported.. */
  function canvasSupported(){
    canvas = document.getElementsByTagName("canvas")[0];
    ctx = canvas.getContext('2d');
    return( !!(ctx));
  }
   
  /* check that the prerequisites are satisfied, and set up the canvas.. */ 
  function init(){
    console.log('checking prerequisites..');
    if(!hasLocalStorage()){
      alert('Error:\nHTML5:localStorage unavailable.\n\nUpdate your browser.');
      return;
    }
    if(!canvasSupported()){
      alert('Error: HTML5 canvas not supported. Please update your browser.');
      return;
    }else{
      ctx.width = 800; 
			ctx.height= 800; 
    }
    console.log('prerequisites seem to be ok..');
  };

  /* don't pass go without the canvas and localStorage.. */
  init();
  /* 
  
  puzzlePieceData works as below. But, gridContent works like this:
		var keys = [];
			for(var k in obj) keys.push(k);

  */
  
  
      /* State variables */  //  
  var gridContent = {};  /* 
  //  new Array(Math.ceil( ctx.width / 100) * Math.ceil( ctx.height/100)); //{ } ;    	<--- Variable indicating if the grid square:  
	at location:  '(' + i.toString() +',' + j.toString() + ')'   (***) 
      is occupied. 
      
      The variable holds a name (a number >=0) of the occupying 
      puzzle piece. If the grid location is empty, the value is set to -1;
      
      gridContent maps from (***) to the index in puzzlePieceData 
	(or -1 if the square (***) is empty..)
  */
   
  var puzzlePieceData = new Array( Math.ceil( ctx.width / 100) * Math.ceil( ctx.height/100));
  for( var i=0; i<puzzlePieceData.length; i++){
    puzzlePieceData[i] = { 'text':'' } ; //let's add a 'text' property later.. and other properties. 
  }
  var nextPuzzlePieceName = 0;

  var pickThis = ''; //this gets set to a certain 'cI' if a certain grid element gets picked. 
  var selectedItem = ''; /* Something that gets picked will get selected. You can unselect it by rePicking. */
  var selectedX  = '';
  /* set up keyboard handlers, and keyboard state variables.. */
  var lastKeyPressed = ''; //track the last key pressed (onkeydown).. 
  
  
    /* Persistent variables schema..  
      Persistent variables stored in string format. 
      When initialized, if direct conversion to INT possible, 
      perform that conversion!!!!!
      
      Add method for assigment (that does the "backup"). 
  
 
      Have to "know" what your variables are, we won't save a list. 
      
Supported Schema:
	var nextPuzzlePieceName = 0; 	      	(simple) 
   	var gridContent = { } ;  	   	(dict) 
   	puzzlePieceData[i] = { 'text':'' } ;  	(array of dict) 
   	
   	We'll use a character that isn't on the keyboard for our separator, 
   	- need a data separator: â™ 
   	- need a special separator for our "pair" expressions: -  
   	
   	
   	Object.keys( gridContent)
	["0-0", "0-1", "0-2", "0-3", "0-4", "0-5", "0-6", "0-7", "0-8", "1-0", "1-1", "1-2", "1-3", "1-4", "1-5", "1-6", "1-7", "1-8", "2-0", "2-1", "2-2", "2-3", "2-4", "2-5", "2-6", "2-7", "2-8", "3-0", "3-1", "3-2", "3-3", "3-4", "3-5", "3-6", "3-7", "3-8", "4-0", "4-1", "4-2", "4-3", "4-4", "4-5", "4-6", "4-7", "4-8", "5-0", "5-1", "5-2", "5-3", "5-4", "5-5", "5-6", "5-7", "5-8", "6-0", "6-1", "6-2", "6-3", "6-4", "6-5", "6-6", "6-7", "6-8", "7-0", "7-1", "7-2", "7-3", "7-4", "7-5", "7-6", "7-7", "7-8", "8-0", "8-1", "8-2", "8-3", "8-4", "8-5", "8-6", "8-7", "8-8"]

 
	Object.keys(puzzlePieceData)
	["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "60", "61", "62", "63"]
 */
 
	function getKeys(obj) {
		var r = []
		for (var k in obj) {
			if (!obj.hasOwnProperty(k)) 
				continue
			r.push(k)
		}
		return r
	}
		
 
  function varInit(variableName){  /* init variable, but restore if not already defined... */
		console.log('********varInit('+variableName.toString()+')');
		eval('console.log(' + variableName+');');

	
		/* to get the variable's keys, need to discern between 
			array and object types.  */
		var myKeys = [];
  	var isArray = eval( variableName+' instanceof Array ');
  	console.log('isArray =',isArray);
		if(isArray){
			myKeys = eval('Object.keys('+variableName+');');
		}else{

			//myKeys = [ ];
			console.log('pushing...myVariable:::::');
			var myVariable = eval(variableName);
			console.log(myVariable);
			/*for( var k in myVariable){
				myKeys.push(k);
				console.log('push:',k);
			}*/
			myKeys = getKeys( myVariable);
			//eval('for(var k in '+variableName+'){ myKeys.push(k); console.log("push",k);}');
		}
		console.log('---------------------------- is this working???\n\n');
		eval('console.log('+myKeys+');');
		console.log('-----------------------------------------------');
		
		/* Don't wipe any keys that are in there..*/
    var varType =eval('typeof('+variableName+')');
    var item = localStorage.getItem(variableName);  
    /* First case: "leaf" type data:.. */
    if( varType == 'string' || varType == 'number'){
			//leaf type of object..
			
			if(item==null){
				//item was not initialized. 
				localStorage.setItem(variableName, eval(variableName).toString());
			}else{
				//item was initialized. 
				var myValue=null;
				try{
					//is it an int?
					myValue = parseInt( item); 
					eval(variableName+' = myValue;');
				}catch(e){
					//not an int.. 
					try{
						//how about float?
						myValue = parseFloat( item);
						eval(variableName+' = myValue;');
					}catch(e){
						eval(variableName+' = item;');
					}
				}//value is not int.. 
			}
			/* next case: dict-type data: */
		}else if( varType=='object'){
			//check for keys..
			
			/* calculate a histogram on the types of keyed data: */
			var myCount = {};
			for(var i=0; i<myKeys.length; i++){
				var valType = eval('typeof(myKeys[i]);');
				if( myCount[valType]){
					myCount[valType]+=1;
				}else{
					myCount[valType]=1;
				}
			}
			if( myCount.length >1){
				console.log('Error: more than one key type detected.');

				
			}else{
				console.log('Note: detected one type of key.');
				/* 
					>	varInit('gridContent')
					<   memory.html:117 Note: detected one type of key.
					
					
					> varInit('puzzlePieceData')
					< memory.html:117 Note: detected one type of key.

				.. now we need to differentiate according to the two values:... 
				
					Type  I)  var gridContent = { } ;  	   		     (dict) 
					Type II)  puzzlePieceData[i] = { 'text':'' } ; (array of dict)

				*/
				var valueType = 'string';
				for(var i in myKeys){
					valueType = eval('typeof('+variableName+'[i]);');
				}
				if( valueType=='string'){
					console.log(variableName,': data type I) -->');
				}else{
					console.log(variableName,': data type II) -->');
				}
				
				/* 
					Startup info confirms that this is working.. 
		
										checking prerequisites..
						memory.html:190 prerequisites seem to be ok..
						memory.html:119 Note: detected one type of key.
						memory.html:139 gridContent : data type I)
						memory.html:119 Note: detected one type of key.
						memory.html:141 puzzlePieceData : data type II)
						
						Sample data:
						
						gridContent['0-0']:
							0
						puzzlePieceData['0']['text']:
							"asdf"
				
				*/
				if( item==null){
					console.log('console.log(">>>>>>>eval: "+Object.keys('+variableName+').toString());');
					eval('console.log(">>>>>>>eval: "+Object.keys('+variableName+').toString());'); 
				//console.log('eval: ', ('Object.keys('+variableName+');'), eval('Object.keys('+variableName+');'));
					if( valueType=='string'){
						
						
						//console.log(variableName,': data type I)'); //gridContent: {0-0: 0, 0-1:
						var s = ''; var j=0;
						for(var i in eval('Object.keys('+variableName+');')){
						  if(j>0){ s+=',';}
							s+= (i.toString()+': '+ eval(variableName+'[i]').toString());
							j++;
						}
						console.log('s: ',s);
					}else{
						//console.log(variableName,': data type II)');
					}
					//localStorage.setItem( 
				}
				
				
			}
		}else{
			console.log('Non-supported type: ',varType);
		}
	}
  
  /* transfer inMemory variable to localStorage.. */
	function varSave(variableName){
		var varType =eval('typeof('+variableName+')');
		if( varType == 'string' || varType == 'number'){
			//leaf type of object..
			var item = localStorage.setItem(variableName, eval(variableName).toString());
		}
	}
	if(false){
		
		var progIter = 0;
		varInit('progIter');
		document.getElementById("h1").innerHTML = "Recognition Memory Experiment Framework (iter="+progIter.toString()+")";
		progIter++;
		varSave('progIter');
	}
  
  var invColor;
  var img = new Image(); 
  img.src = 'http://web.uvic.ca/~ashy/memory/uvicAerial.jpg';
  var avgColor = [0.,0.,0.];
  
    
  function inverseColor( rgbColor){
    /*Return the string for the complementary inverse color, 
    for a color string of the format:
      rgb(230,226,224) 
    */
    var values = (rgbColor.slice(4, rgbColor.length-1)).split(',');
    /* should now have a string array like this:
	  230,226,224  */
    var s = 'rgb(';
    for( var i=0; i<3; i++){
      s+= (255-parseInt(values[i])).toString();
      if( i<2){
				s+=',';
      }
    }
    return(s+')'); 
  }
  
  img.onload = function() {
    /* 
      When the background image loads, calculate an approximation 
	to the average colour of the image. Ideally we would use 
	an offscreen canvas or other method to do this, if we had more time.
	
	First: set the canvas size to the background image:
    */
    ctx.width = img.width; 
    ctx.height = img.height;
    
    /* 
      Draw the background image (temporarily) on the canvas. Read the data
	values back in, and sample them to get an approximate average 
	value of the colour of the background image. 
    */
    ctx.drawImage(img, 0, 0); //write bg image to the canvas. 
    var imageData = ctx.getImageData(0, 0, img.width, img.height);
    var pix = imageData.data; //read back the pixel data. 
    var nn = 0;	//count the number of points used in the sample. 
    var nSkip = 7777; 
    /* use a sample/fraction of the image data, to save time.. */
    for (var i = 0; i < pix.length; i+=4) {
      /* Use (1/nSkip) of the image pixels. */
      if( i%nSkip==0){
				var r = 1.*pix[i  ];//red
				var g = 1.*pix[i+1];//green
				var b = 1.*pix[i+2];//blue
				avgColor[0]+=r; avgColor[1]+=g; avgColor[2]+=b; 
				nn+=1.; /* keep track of the number of elements in the sample. */
			}/* Note: pix[i+3] is 'alpha' (the fourth element) */
		}
    /* divide by sample mean to get an approximation of the average: */
    avgColor[0]/=nn;avgColor[1]/=nn; avgColor[2]/=nn;
    /* calculate the inverted colour. */
    invColor = 'rgb(' 
			+(255-Math.floor(avgColor[0])).toString() +','
			+(255-Math.floor(avgColor[1])).toString() +','
			+(255-Math.floor(avgColor[2])).toString() 
			+')'; 
    avgColor = inverseColor( invColor);//represent the original in the same format. 
  } //img.onload = function() 

  ctx.width = 800; 
  ctx.height= 800; 


  
  /* convert a string of form:
	'1,2'
	
     to a pair of integers of form:
	[1,2]
  */
  function toPair( ci){
    var parts = ci.split('-');  //use - as separator for our "pair" construction. 
    for(var i=0; i<2; i++){
      parts[i]=parseInt(parts[i]);
    }
    return( parts);
  }
  
  /* 
    Disable scroll down when spacebar is pressed
  */
  window.onkeydown = function(e) { 
    return !(e.keyCode == 32);
  };

  /* Check if a string (or character) is all upper case. */
  function allUpperCase(s){
    var ss = s.toString();
    return( ss == ss.toUpperCase());
  }

  
  var shiftKey = false; 
  /*
    
  */


  
  function keyboard_module(onUpdate) {
    var kb = {};
    var unicode_mapping = {};
    /* handler for key down event.. override automatic key repeats!
    
	With the exception of BACKSPACE.. !!!
    */
    document.onkeydown = function(e) {
      //console.log( 'key code: '+ (e.keyCode).toString()+ ' charCode: '+(e.charCode).toString()); 
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      if(lastKeyPressed!='' && (lastKeyPressed==key) && ( unicode!=8)){
        return;
      }
      console.log('unicode: ',unicode)
      lastKeyPressed =key;
      kb[key] = true;
      if (onUpdate) {
        onUpdate(kb);//alert(key);
      }
      if( unicode ==16){
				shiftKey =true; 
      }
      if( selectedItem!=''){
				//console.log('Selected item!!!!');
				var myName = gridContent[ selectedItem];
				var curText = (puzzlePieceData[myName])['text'];
							var newValue = String.fromCharCode(unicode);
				if( unicode==8){
					/* backSpace (need to add other 'control' characters..) */
					if( curText.length >1){
						curText = curText.slice(0, curText.length-1);
					}
				}else{
					//var gridCoords = toPair( selectedItem);

					if( unicode ==13){
						newValue = '\n';
						/* right now enter doesn't effectively do anything. 
					(would have to modify the wrapText method). 
						*/
					}
					function reMap(u,newVal, shiftVal){
						var ret = newValue; 
						if(unicode==u){
							ret = newVal; 
							if(shiftKey){
								ret = shiftVal; 
							}
						}
						return(ret);
					}
					newValue= reMap(190,  '.',  '>');
					newValue= reMap(188,  ',',  '<'); //might need to  
					newValue= reMap(186,  ';',  ':');
					newValue= reMap(222,  "'",  '"');
					newValue= reMap(191,  '/',  '?');
					newValue= reMap(219,  '[',  '{');
					newValue= reMap(221,  ']',  '}');
					newValue= reMap(220,  "\\", '|'); //might need to disable backslash later. 
					newValue= reMap(221,  ']',  '}');
					newValue= reMap(192,  '`',  '~');
					newValue= reMap( 49,  '1',  '!');
					newValue= reMap( 50,  '2',  '@');    
					newValue= reMap( 51,  '3',  '#');
					newValue= reMap( 52,  '4',  '$');
					newValue= reMap( 53,  '5',  '%');
					newValue= reMap( 54,  '6',  '^');
					newValue= reMap( 55,  '7',  '&');
					newValue= reMap( 56,  '8',  '*');
					newValue= reMap( 57,  '9',  '(');
					newValue= reMap( 48,  '0',  ')');
					newValue= reMap(189,  '-',  '_');
					newValue= reMap(187,  '=',  '+');
					if( shiftKey ){
						newValue = (newValue.toString()).toUpperCase();
					}else{
						newValue = (newValue.toString()).toLowerCase();
					}
					curText+= newValue.toString(); //unicode.toString();
				}
				(puzzlePieceData[myName])['text']=curText;
			}
		}
    /* handler for key up event.. */
    document.onkeyup = function(e) {
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      lastKeyPressed = '';
      delete kb[key];
      if (onUpdate) {
        onUpdate(kb);
      }

			if( unicode ==16){
				shiftKey =false; 
			}
    }
    /* function to check the keyboard state.. */
    function getKey(unicode) {
      if (unicode_mapping[unicode]) {
        var key = unicode_mapping[unicode];
      } else {
        var key = unicode_mapping[unicode] = String.fromCharCode(unicode);
      }
      return key;
    }
    return kb;
  }/* function keyboard_module(onUpdate).. keyboard handler..  */

  /* by default, log which keys are currently down.. */
  function testing(kb) {
    console.log('These keys are down: ', kb); //These keys are down:  Object {S: true} //e.g., for S pressed... 
  }

  /* set up the keyboard event handling scheme above.. */
  var keyboard = keyboard_module(testing);
  


  /* function to convert window mouse coordinates to canvas mouse coordinates. */
  function windowToCanvas(canvas, x,y){
    var bbox = canvas.getBoundingClientRect();
    return { x:(x-bbox.left)*(canvas.width/bbox.width),
       y:(y-bbox.top) *(canvas.height/bbox.height)};
    /*  
      //Example use of windowToCanvas:  
        canvas.onmousemove=function(e){
          var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        };
      //End example..
    */
  }
  
  //----------------------------------------------------------------------------
var cw=canvas.width;
var ch=canvas.height;
function reOffset(){
  var BB=canvas.getBoundingClientRect();
  offsetX=BB.left;
  offsetY=BB.top;        
}
var offsetX,offsetY;
reOffset();


function makeBeziers(s){
  var ret = ([
    {cx1:0,  cy1:15,  cx2:35,cy2:15, ex:37, ey:5},   // left shoulder
    {cx1:37, cy1:5,  cx2:40,cy2:0,  ex:38, ey:-5},  // left neck
    {cx1:38, cy1:-5, cx2:20,cy2:-20,ex:50, ey:-20}, // left head
    {cx1:50, cy1:-20,cx2:80,cy2:-20,ex:62, ey:-5},  // right head
    {cx1:62, cy1:-5, cx2:60,cy2:0,  ex:63, ey:5},   // right neck
    {cx1:63, cy1:5,  cx2:65,cy2:15, ex:100,ey:15},   // right shoulder
  ]);
  for( var i = 0; i<ret.length; i++){
     ret[i].cx1*=s;
     ret[i].cx2*=s;
     ret[i].cy1*=s;
     ret[i].cy2*=s;
     ret[i].ex*=s;
     ret[i].ey*=s;
  }
  return ret;
}


function drawUp(transX,transY, reverseDirection, pw){
  //ctx.translate(transX,transY);
  var bSet = makeBeziers(1.*(pw/100.));
  var tx  = transX; 
  var ty  = transY;
  if( reverseDirection==true){
    for(var i=bSet.length-1; i>=0; i--){
      var b=bSet[i];
      ctx.bezierCurveTo(b.ex+tx,b.ey+ty,b.cx2+tx,b.cy2+ty,b.cx1+tx,b.cy1+ty);
    }
  }else{
    for(var i=0;i<bSet.length;i++){
      var b=bSet[i];
      ctx.bezierCurveTo(b.cx1+tx,b.cy1+ty,b.cx2+tx,b.cy2+ty,b.ex+tx,b.ey+ty);
    }
  }
}
function drawLine(x,y,u,v){ //ctx.beginPath(); 
  ctx.moveTo(x,y);  
  ctx.lineTo(u,v); //ctx.closePath(); //ctx.stroke();
}

/* Draw a puzzle piece that only can have vertical connections. */
function drawPiece(aTransX,aTransY, /* <-translation offset.. */ pw,ph /* <-puzzle piece dims..*/ , isSelected, cI){ 
  
  
  var transX = aTransX; 
  var transY = aTransY;
  
  /*if(isSelected){
    var parts = selectedItem.split(',');
    transX -=( selectedX[0] - 100*parseInt(parts[0]));
    transY -=( selectedX[1] - 100*parseInt(parts[1]));
  }
  */
  
  ctx.lineWidth=0.5;
  ctx.strokeStyle='blue';
  var sizeP = ph;//100; 
  var pp = 15 * (100./pw);
  //sizeP = 100-pp;
  /* Draw the shape (without edges). */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,transX, transY+pp);
  drawUp(transX, transY, false, pw);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawUp(transX, transY+sizeP, true, pw);//false);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.closePath();
  if( isSelected==true){
    ctx.fillStyle = avgColor;//inverseColor(invColor);
  }else{
    ctx.fillStyle =invColor;//'#8ED6FF';
   }
  //console.log(invColor, inverseColor(invColor));
  ctx.fill();
  
  /* draw the picking area.. MAYBE only draw this when the piece is highlighted!!! */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,   transX, transY+pp);
  drawLine(     transX, transY+pp,transX+pw, transY+pp);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawLine(  transX+pw, transY+sizeP+pp,transX, transY+sizeP+pp);
  ctx.closePath();
  ctx.strokeStyle='green';
  ctx.stroke();
  
  /* Now, draw the text content..  */
  function wrapText(str, startY, isSelected){  //with some help from ashblue
    var words = str.split(" ");
    var myX = 10;
    var myY = 50;
    var line = '';
    var lines = [ ] ;
    var lineTest = '';
    var fontSize = 11;
    ctx.font = fontSize +"px Arial";
    ctx.fillStyle = isSelected?invColor:avgColor;//'blue';
    
    for(var j=0; j<words.length; j++){
      lineTest = line + words[j] + ' ';
      if( ctx.measureText(lineTest).width > 100){
	myY = lines.length * fontSize + fontSize;
	lines.push( {text: line, height: myY});
	line = words[j] + ' ';
      }else{
	line = lineTest; 
      }        
    } 
    // Catch last line in-case something is left over
    if (line.length > 0) {
      currentY = lines.length * fontSize + fontSize;
      lines.push({ text: line.trim(), height: currentY });
    }   
    // Visually output text
    //ctx.clearRect(0, 0, canvas.width, canvas.height);
    for (var j = 0, len = lines.length; j < len; j++) {
      ctx.fillText(lines[j].text, transX, lines[j].height+ startY);
    }
  }
  var myString = /*(gridContent[cI].toString())+':'+*/ (puzzlePieceData[gridContent[cI]])['text'];
  wrapText( myString, transY+15, isSelected); 
  
  
}



/*
  Draw the grid. 
  
  Also, (for now), randomly initialize (empty) puzzle piece
    elements on the grid. 
*/
function drawGrid(cw, ch){
  /*
     Draw the grid. 
  */
  var v = 36;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth=1;
  ctx.strokeStyle='blue';
  ctx.setLineDash([5, 15]);
  for( var i=0; i<cw/100; i++){
    drawLine( i * 100, 0+v, i*100, ch+v);    ctx.stroke();
  }
  for(var j=0; j<ch/100; j++){
    drawLine(0, j*100+v, cw, j*100+v);     ctx.stroke();
  }
  
  /* Randomly initialize puzzle piece elements on the grid (for now).. 
	Change this later.. 
  */
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
	//pass
      }else{
	if( Math.random()<.4){////if( i%3==0 || j%==0){
	  gridContent[cI]=(nextPuzzlePieceName++);
	}else{
	  gridContent[cI]=-1;
	}
      }
    }
  }
 ctx.globalAlpha = 1.;
}

/*
  Draw the puzzle pieces on the grid. 
*/
function drawGridContent(){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+'-'+j.toString();
      if( cI in gridContent){
	if(gridContent[cI]>=0){
	  if( pickThis == cI){
	    /* Mouse motion: puzzle piece follows mouse coordiantes: */
	    drawPiece(mx, my, 100,100, cI==selectedItem, cI);//0 + 100*i,21 + 100*j, 100,100);
	  }else{
	     //Puzzle piece is static: 
	    drawPiece(0 + 100*i,21 + 100*j, 100,100, cI==selectedItem, cI);
	  }
	      //draw(mx, my, 100, 100);
	}
      }
    }
  }
}


var w = 800;//window.innerWidth-20;
var h = 800;//window.innerHeight-20; 
drawGrid(w,h);
drawGridContent();

/*
	before drawing or initializing the grid, try to restore it:
*/



varInit('gridContent');
console.log('++++++++++++++++++++++++gridContent', gridContent);
console.log('getKeys(gridContent)');
var myKeysAre = getKeys(gridContent);
console.log(myKeysAre);
console.log('Object.keys(gridContent)', Object.keys(gridContent));
for (var v in gridContent){
	console.log('push v in gridContent:---> ', v);
}
console.log('console.log(Object.keys(gridContent));');
console.log(Object.keys(gridContent));
console.log('JSON.stringify(gridContent)');
console.log(JSON.stringify(gridContent));



if(false){
	varInit('puzzlePieceData');
	console.log('puzzlePieceData, getKeys():::::::::::::::::::::;', getKeys(puzzlePieceData));
}
//----------------------------------------------

 /* Global variables to track animation loop.. */
  var i=0; //loop iteration counter. 
  var movingAverage = 0.; //moving average for fps calc... 
  var t0 = window.performance.now(); //start time..
  var t2 = 0; var t1=t0; //times used in loop..
  
  
  var mx, my; mx=my=0;

  /* function to execute, animation loop.. */
  function frame(){
    //document.bgColor = "#FFFFFF"; //"#000000"

    var w = 800;//window.innerWidth-20;
    var h = 800;//window.innerHeight-20; 
    /* set the canvas size dynamically so that the software is device independent and so on... */    
    canvas.width  = w;
    canvas.height = h;


    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    
    /* Image scaling approach for logo (right corner) */
    /*
    ctx.save();
      ctx.globalAlpha = 1.0;
      var lW = logoImg.width; var lH = logoImg.height;
      var wf = (w-20)/(5. * lW);
      ctx.drawImage( logoImg, w-(lW*wf),h-(lH*wf),lW*wf, lH*wf);
    ctx.restore();
    */
    
    drawGrid(w,h);
    drawGridContent();
  
    /*loop profiling section */
    var t2 = window.performance.now()
    if( i==1){
      movingAverage = t1 - t0;
    }else{
      movingAverage = (movingAverage +(t2-t1))/2.;
    }
    t1 = t2; 
    if (i % 1000 == 0) {
      console.log(movingAverage.toString()+(' mS = ')+((1./(movingAverage/1000.)))+(' fpS'));
    }
    /* Total time elapsed since start.. */
    var timeElapsed = Math.ceil(( t1-t0)/1000.);  i += 1;
    if(false){
      /* print out DOM element names... 
      
	 Was looking to see if generally there was a pattern, 
	  the two methods for exploring the DOM don't seem 
	  to give the same results. 
      */
      var all = document.getElementsByTagName("*");
      for (var i=0, max=all.length; i < max; i++) {
	// Do something with the element here	
	console.log( all[i].toString() + ' i='+ i.toString());
      }

      var currentNode,
      ni = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_ELEMENT);

      while(currentNode = ni.nextNode()) {
	console.log(currentNode.nodeName);
      }
    }
  };
  
  /* Mouse button down event */
   canvas.addEventListener("mousedown", function(e){  /* e.clientX, e.clientY */
    /* mouse down event listener code... */ 
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    var cw = canvas.width;
    var ch = canvas.height;
    var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
    /* Did we click on a 'valid' grid square? */
    if( cI in gridContent){
      pickThis = cI; 
      /* was this item already selected? */
      if( selectedItem ==cI){
	/* If the picked item was already selected, unselect it. */
	selectedItem = '';
      }else{
	/* If the picked item was not already selected, select it! */
	selectedItem = cI;
	/* Track the starting mouse position for the selection 
	    .. the idea was to use this as an "offset", later. 
	*/
	selectedX = [mx, my]; 
      }
    }
    
  });

  /* Mouse up event.. */
  canvas.addEventListener("mouseup", function(e){  /* e.clientX, e.clientY */
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    if( pickThis!=''){
      var cI = Math.floor( mx / 100)+'-'+ Math.floor( my/100); 
      if( cI in gridContent){
	if( gridContent[cI]<0 /*==''*/ /* only move to empty space*/ 
	    && (cI!=pickThis)  /* if dest=src then don't move!!!!..  */ ){
	  plopSound.play();
	  console.log('Overwriting '+cI+' with '+pickThis+ ' puzzlePieceName=' 
	    +(gridContent[pickThis]).toString());
	  gridContent[cI]=gridContent[pickThis];
	  gridContent[pickThis]=-1;//'';
	}
      }
    }
    /* keep the status quo. */
    pickThis ='';
  });
  
  canvas.onmousemove=function(e){
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    return;
    console.log(
	'x '+(e.clientX).toString()+' y '+(e.clientY).toString()
      + ' cx '+(loc.x).toString()
      + ' cy '+(loc.y).toString()
      + ' i  '+Math.floor(loc.x / 100).toString()
      + ' j  '+Math.floor(loc.y / 100).toString()
      );
  };

  /* this command actually starts the animation-loop:.. */
  var id = setInterval(frame, 55);  //Can reduce this number to decrease latency..  
  
</script>
</body>
</html>
