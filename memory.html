<!DOCTYPE html>
<meta http-equiv="content-type" content="text/html;charset=utf-8" />

<head>
<link rel="stylesheet" href="main.css">
<title>Recognition Memory Experiment Framework</title>
<img src="uvicSmall.png" >
<h1>Recognition Memory Experiment Framework</h1>
</head>
<body>
<canvas id="canvasID" width="800" height="800">Error: HTML5 canvas unupported.</canvas><!--Dynamically resize this later?
title="invert" class="invert"   (put that in img section, to invert the image...  
-->
<embed src="20160928requirements.pdf" width="800" height="800" type='application/pdf' class="invert">
<script>  
  var plopSound = new Audio('plop.mp3'); //  plopSound.play();
  /* check if localStorage is supported.. */
  function hasLocalStorage(){ 
    var test = 'test';
    try{
      localStorage.setItem(test, test);
      localStorage.removeItem(test);
      return true;
    }catch(e){
      return false;
    }
  }
  
  /* keep hooks to our html5 canvas, and canvas.context.. */
  var canvas, ctx; 

  /* check if html5-canvas is supported.. */
  function canvasSupported(){
    canvas = document.getElementsByTagName("canvas")[0];
    ctx = canvas.getContext('2d');
    return( !!(ctx));
  }
   
  /* check that the prerequisites are satisfied, and set up the canvas.. */ 
  function init(){
    console.log('checking prerequisites..');
    if(!hasLocalStorage()){
      alert('Error:\nHTML5:localStorage unavailable.\n\nUpdate your browser.');
      return;
    }
    if(!canvasSupported()){
      alert('Error: HTML5 canvas not supported. Please update your browser.');
      return;
    }
    console.log('prerequisites seem to be ok..');
  };

  /* don't pass go without the canvas and localStorage.. */
  init();
  var invColor;
  var img = new Image(); 
  img.src = 'http://web.uvic.ca/~ashy/memory/uvicAerial.jpg';
  var avgColor = [0.,0.,0.];
  img.onload = function() {
    ctx.width = img.width;
    ctx.height = img.height;
    ctx.drawImage(img, 0, 0);
    var imageData = ctx.getImageData(0, 0, img.width, img.height);
    var pix = imageData.data;
    var nn = 0;	
    for (var i = 0; i < pix.length; i+=4) {
      if( i%10000==0){
	var r = 1.*pix[i  ];
	var g = 1.*pix[i+1]; 
	var b = 1.*pix[i+2];
	avgColor[0]+=r; avgColor[1]+=g; avgColor[2]+=b; 
	nn+=1.;
	//console.log(r,g,b); 
      }
      // i+3 is alpha (the fourth element)
    }
    avgColor[0]/=nn;avgColor[1]/=nn; avgColor[2]/=nn;
    //console.log(pix.length); //console.log( avgColor[0] , avgColor[1], avgColor[2]);
    invColor = "rgb(" 
		+(255-Math.floor(avgColor[0])).toString()
		+ ","
		+(255-Math.floor(avgColor[1])).toString()
		+","
		+(255-Math.floor(avgColor[2])).toString()
		+")"; 
  }
  

  ctx.width = 800; 
  ctx.height=800; 

  
  /* set up keyboard handlers, and keyboard state variables.. */
  var lastKeyPressed = ''; //track the last key pressed (onkeydown).. 
  function keyboard_module(onUpdate) {
    var kb = {};
    var unicode_mapping = {};
    /* handler for key down event.. override automatic key repeats!*/
    document.onkeydown = function(e) {
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      if(lastKeyPressed!='' && (lastKeyPressed==key)){
        return;
      }lastKeyPressed =key;
      kb[key] = true;
      if (onUpdate) {
        onUpdate(kb);//alert(key);
      }
    }
    /* handler for key up event.. */
    document.onkeyup = function(e) {
      var unicode = e.charCode ? e.charCode : e.keyCode
      var key = getKey(unicode);
      lastKeyPressed = '';
      delete kb[key];
      if (onUpdate) {
        onUpdate(kb);
      }
    }
    /* function to check the keyboard state.. */
    function getKey(unicode) {
      if (unicode_mapping[unicode]) {
        var key = unicode_mapping[unicode];
      } else {
        var key = unicode_mapping[unicode] = String.fromCharCode(unicode);
      }
      return key;
    }
    return kb;
  }/* function keyboard_module(onUpdate).. keyboard handler..  */

  /* by default, log which keys are currently down.. */
  function testing(kb) {
    console.log('These keys are down: ', kb); //These keys are down:  Object {S: true} //e.g., for S pressed... 
  }

  /* set up the keyboard event handling scheme above.. */
  var keyboard = keyboard_module(testing);
  


  /* function to convert window mouse coordinates to canvas mouse coordinates. */
  function windowToCanvas(canvas, x,y){
    var bbox = canvas.getBoundingClientRect();
    return { x:(x-bbox.left)*(canvas.width/bbox.width),
       y:(y-bbox.top) *(canvas.height/bbox.height)};
    /*  
      //Example use of windowToCanvas:  
        canvas.onmousemove=function(e){
          var loc = windowToCanvas(canvas, e.clientX, e.clientY);
        };
      //End example..
    */
  }
  
  //----------------------------------------------------------------------------
var cw=canvas.width;
var ch=canvas.height;
function reOffset(){
  var BB=canvas.getBoundingClientRect();
  offsetX=BB.left;
  offsetY=BB.top;        
}
var offsetX,offsetY;
reOffset();


function makeBeziers(s){
  var ret = ([
    {cx1:0,  cy1:15,  cx2:35,cy2:15, ex:37, ey:5},   // left shoulder
    {cx1:37, cy1:5,  cx2:40,cy2:0,  ex:38, ey:-5},  // left neck
    {cx1:38, cy1:-5, cx2:20,cy2:-20,ex:50, ey:-20}, // left head
    {cx1:50, cy1:-20,cx2:80,cy2:-20,ex:62, ey:-5},  // right head
    {cx1:62, cy1:-5, cx2:60,cy2:0,  ex:63, ey:5},   // right neck
    {cx1:63, cy1:5,  cx2:65,cy2:15, ex:100,ey:15},   // right shoulder
  ]);
  for( var i = 0; i<ret.length; i++){
     ret[i].cx1*=s;
     ret[i].cx2*=s;
     ret[i].cy1*=s;
     ret[i].cy2*=s;
     ret[i].ex*=s;
     ret[i].ey*=s;
  }
  return ret;
}


function drawUp(transX,transY, reverseDirection, pw){
  //ctx.translate(transX,transY);
  var bSet = makeBeziers(1.*(pw/100.));
  var tx  = transX; 
  var ty  = transY;
  if( reverseDirection==true){
    for(var i=bSet.length-1; i>=0; i--){
      var b=bSet[i];
      ctx.bezierCurveTo(b.ex+tx,b.ey+ty,b.cx2+tx,b.cy2+ty,b.cx1+tx,b.cy1+ty);
    }
  }else{
    for(var i=0;i<bSet.length;i++){
      var b=bSet[i];
      ctx.bezierCurveTo(b.cx1+tx,b.cy1+ty,b.cx2+tx,b.cy2+ty,b.ex+tx,b.ey+ty);
    }
  }
}
function drawLine(x,y,u,v){ //ctx.beginPath(); 
  ctx.moveTo(x,y);  
  ctx.lineTo(u,v); //ctx.closePath(); //ctx.stroke();
}

/* Draw a puzzle piece that only can have vertical connections. */
function draw(transX,transY, /* <-translation offset.. */ pw,ph /* <-puzzle piece dims..*/ ){ 
  ctx.lineWidth=0.5;
  ctx.strokeStyle='blue';
  var sizeP = ph;//100; 
  var pp = 15 * (100./pw);
  //sizeP = 100-pp;
  /* Draw the shape (without edges). */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,transX, transY+pp);
  drawUp(transX, transY, false, pw);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawUp(transX, transY+sizeP, true, pw);//false);
  ctx.setTransform(1,0,0,1,0,0);
  ctx.closePath();
  ctx.fillStyle =invColor;//'#8ED6FF';
  ctx.fill();
  
  /* draw the picking area.. MAYBE only draw this when the piece is highlighted!!! */
  ctx.beginPath();
  drawLine(  transX, transY+sizeP+pp,   transX, transY+pp);
  drawLine(     transX, transY+pp,transX+pw, transY+pp);
  drawLine(  transX+pw, transY+pp, transX+pw, transY+sizeP+pp);
  drawLine(  transX+pw, transY+sizeP+pp,transX, transY+sizeP+pp);
  ctx.closePath();
  ctx.strokeStyle='green';
  ctx.stroke();

}


var gridContent = { } ;

function drawGrid(cw, ch){
  var v = 36;
  ctx.globalAlpha = 0.5;
  ctx.lineWidth=1;
  ctx.strokeStyle='blue';
  ctx.setLineDash([5, 15]);
  for( var i=0; i<cw/100; i++){
    drawLine( i * 100, 0+v, i*100, ch+v);    ctx.stroke();
  }
  for(var j=0; j<ch/100; j++){
    drawLine(0, j*100+v, cw, j*100+v);     ctx.stroke();
  }
  
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+','+j.toString();
      if( cI in gridContent){
      }else{
	if( Math.random()<.4){////if( i%3==0 || j%==0){
	  gridContent[cI]=1;
	}else{
	  gridContent[cI]=0;
	}
      }
    }
  }
 ctx.globalAlpha = 1.;

}
var pickThis = ''; //this gets set to a certain 'cI' if that one is picked.

function drawGridContent(){
  for( var i =0; i<=cw/100; i++){
    for(var j=0; j<=ch/100; j++){
      var cI = i.toString()+','+j.toString();
      if( cI in gridContent){
	if(gridContent[cI]==1){
	  if( pickThis == cI){
	    /* Mouse motion: puzzle piece follows mouse coordiantes: */
	    draw(mx, my, 100,100);//0 + 100*i,21 + 100*j, 100,100);
	  }else{
	     //Puzzle piece is static: 
	    draw(0 + 100*i,21 + 100*j, 100,100);
	  }
	      //draw(mx, my, 100, 100);
	}
      }
    }
  }
}

//----------------------------------------------

 /* Global variables to track animation loop.. */
  var i=0; //loop iteration counter. 
  var movingAverage = 0.; //moving average for fps calc... 
  var t0 = window.performance.now(); //start time..
  var t2 = 0; var t1=t0; //times used in loop..
  
  
  var mx, my; mx=my=0;

  /* function to execute, animation loop.. */
  function frame(){
    //document.bgColor = "#FFFFFF"; //"#000000"

    var w = 800;//window.innerWidth-20;
    var h = 800;//window.innerHeight-20; 
    /* set the canvas size dynamically so that the software is device independent and so on... */    
    canvas.width  = w;
    canvas.height = h;


    ctx.beginPath();
    ctx.rect(0, 0, w, h);
    ctx.fillStyle = 'white';
    ctx.fill();
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'black';
    ctx.stroke();
    
    /* Image scaling approach for logo (right corner) */
    /*
    ctx.save();
      ctx.globalAlpha = 1.0;
      var lW = logoImg.width; var lH = logoImg.height;
      var wf = (w-20)/(5. * lW);
      ctx.drawImage( logoImg, w-(lW*wf),h-(lH*wf),lW*wf, lH*wf);
    ctx.restore();
    */
    
    drawGrid(w,h);
    drawGridContent();
  
    /*loop profiling section */
    var t2 = window.performance.now()
    if( i==1){
      movingAverage = t1 - t0;
    }else{
      movingAverage = (movingAverage +(t2-t1))/2.;
    }
    t1 = t2; 
    if (i % 1000 == 0) {
      console.log(movingAverage.toString()+(' mS = ')+((1./(movingAverage/1000.)))+(' fpS'));
    }
    /* Total time elapsed since start.. */
    var timeElapsed = Math.ceil(( t1-t0)/1000.);  i += 1;
    if(false){
      /* print out DOM element names... */
      var all = document.getElementsByTagName("*");
      for (var i=0, max=all.length; i < max; i++) {
	// Do something with the element here	
	console.log( all[i].toString() + ' i='+ i.toString());
      }

      var currentNode,
      ni = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_ELEMENT);

      while(currentNode = ni.nextNode()) {
	console.log(currentNode.nodeName);
      }
    }
  };
  
   canvas.addEventListener("mousedown", function(e){  /* e.clientX, e.clientY */
    /* mouse down event listener code... */ 
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    var cw = canvas.width;
    var ch = canvas.height;
    var cI = Math.floor( mx / 100)+','+ Math.floor( my/100); 
    if( cI in gridContent){
      pickThis = cI; 
    }
    
  });

  canvas.addEventListener("mouseup", function(e){  /* e.clientX, e.clientY */
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    if( pickThis!=''){
      var cI = Math.floor( mx / 100)+','+ Math.floor( my/100); 
      if( cI in gridContent){
	if( gridContent[cI]=='' /* only move to empty space*/ 
	  && (cI!=pickThis)  /* if dest=src then it's not moving...*/   ){
	  plopSound.play();
	  console.log('Overwriting '+cI+' with '+pickThis);
	  gridContent[cI]=gridContent[pickThis];
	  gridContent[pickThis]='';
	}
      }
    }
    
    pickThis ='';
  });



  canvas.onmousemove=function(e){
    //frame();  
    
    var loc = windowToCanvas(canvas, e.clientX, e.clientY);
    mx = loc.x;
    my = loc.y;
    return;
    console.log('x '+(e.clientX).toString()+' y '+(e.clientY).toString()
		+' cx '+(loc.x).toString()
		+' cy '+(loc.y).toString()
		+' i  '+Math.floor(loc.x / 100).toString()
		+' j  '+Math.floor(loc.y / 100).toString()
		/*+' cw '+canvas.width.toString()
		+' ch '+canvas.height.toString()*/
      );
  };

  var id = setInterval(frame, 100);  //might reduce this number to decrease latency.. 
  
</script>
</body>
</html>
